<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>八种排序算法原理及 Java 实现</title>
      <link href="/2018/11/21/ba-chong-pai-xu-suan-fa-yuan-li-ji-java-shi-xian/"/>
      <url>/2018/11/21/ba-chong-pai-xu-suan-fa-yuan-li-ji-java-shi-xian/</url>
      
        <content type="html"><![CDATA[<h5 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h5><p>排序算法分为内部排序和外部排序，内部排序把数据记录放在内存中进行排序，而外部排序因排序的数据量大，内存不能一次容纳全部的排序记录，所以在排序过程中需要访问外存。<br><img src="/images/pasted-54.png" alt="upload successful"><br>经常提及的八大排序算法指的就是内部排序的八种算法，分别是冒泡排序、快速排序、直接插入排序、希尔排序、简单选择排序、堆排序、归并排序和基数排序，如果按原理划分，冒泡排序和快速排序都属于交换排序，直接插入排序和希尔排序属于插入排序，而简单选择排序和堆排序属于选择排序，如上图所示。</p><h5 id="2-冒泡排序"><a href="#2-冒泡排序" class="headerlink" title="2. 冒泡排序"></a>2. 冒泡排序</h5><p><strong>2.1基本思想</strong><br>冒泡排序（Bubble Sort）是一种简单的排序算法。它重复访问要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。访问数列的工作是重复地进行直到没有再需要交换的数据，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢 “浮” 到数列的顶端，像水中的气泡从水底浮到水面。<br><img src="https://user-gold-cdn.xitu.io/2018/9/10/165c1650231bab74?imageslim" alt=""></p><p><strong>2.2 算法描述</strong><br>冒泡排序算法的算法过程如下：</p><p>①. 比较相邻的元素。如果第一个比第二个大，就交换他们两个。</p><p>②. 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</p><p>③. 针对所有的元素重复以上的步骤，除了最后一个。</p><p>④. 持续每次对越来越少的元素重复上面的步骤①~③，直到没有任何一对数字需要比较。</p><p><strong>2.3 代码实现</strong>  </p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>fufu<span class="token punctuation">.</span>algorithm<span class="token punctuation">.</span>sort<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Arrays<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * 冒泡排序 * Created by zhoujunfu on 2018/8/2. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BubbleSort</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>array <span class="token operator">==</span> null <span class="token operator">||</span> array<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> length <span class="token operator">=</span> array<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//外层：需要length-1次循环比较</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//内层：每次循环需要两两比较的次数，每次比较后，都会将当前最大的数放到最后位置，所以每次比较次数递减一次</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> length <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">-</span> i<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>array<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> array<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">//交换数组array的j和j+1位置的数据</span>                    <span class="token function">swap</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> j<span class="token punctuation">,</span> j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 交换数组array的i和j位置的数据     * @param array 数组     * @param i 下标i     * @param j 下标j     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> temp <span class="token operator">=</span> array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        array<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> array<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        array<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><strong>2.4 算法效率</strong><br>冒泡排序是稳定的排序算法，最容易实现的排序, 最坏的情况是每次都需要交换, 共需遍历并交换将近 n²/2 次, 时间复杂度为 O(n²). 最佳的情况是内循环遍历一次后发现排序是对的, 因此退出循环, 时间复杂度为 O(n). 平均来讲, 时间复杂度为 O(n²). 由于冒泡排序中只有缓存的 temp 变量需要内存空间, 因此空间复杂度为常量 O(1)。</p><table><thead><tr><th>平均时间复杂度</th><th>最好情况</th><th>最坏情况</th><th>空间复杂度</th></tr></thead><tbody><tr><td>O(n&sup2;)</td><td>O(n)</td><td>O(n&sup2;)</td><td>O(1)</td></tr></tbody></table><p><strong>2.5 交换数字的三种方法</strong><br>我们从冒泡排序的代码中看到了交换两个数字的方法 swap(int[] array, int i, int j)，这里使用了临时变量，而交换数字主要有三种方法，临时变量法、算术法、位运算法、面试中经常会问到，这里简单说一下，代码如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>fufu<span class="token punctuation">.</span>algorithm<span class="token punctuation">.</span>sort<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Arrays<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * Created by zhoujunfu on 2018/9/10. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SwapDemo</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 临时变量法</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Arrays<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">swapByTemp</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Arrays<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 算术法</span>        array <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token function">swapByArithmetic</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Arrays<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 位运算法</span>        array <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token function">swapByBitOperation</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Arrays<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 通过临时变量交换数组array的i和j位置的数据     * @param array 数组     * @param i 下标i     * @param j 下标j     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">swapByTemp</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> temp <span class="token operator">=</span> array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        array<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> array<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        array<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 通过算术法交换数组array的i和j位置的数据（有可能溢出）     * @param array 数组     * @param i 下标i     * @param j 下标j     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span>  <span class="token function">swapByArithmetic</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>        array<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> array<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> array<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        array<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> array<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> array<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        array<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> array<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> array<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 通过位运算法交换数组array的i和j位置的数据     * @param array 数组     * @param i 下标i     * @param j 下标j     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span>  <span class="token function">swapByBitOperation</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>        array<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">^</span>array<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        array<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">^</span>array<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//array[i]^array[j]^array[j]=array[i]</span>        array<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">^</span>array<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//array[i]^array[j]^array[i]=array[j]</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h5 id="3-快速排序"><a href="#3-快速排序" class="headerlink" title="3. 快速排序"></a>3. 快速排序</h5><p><strong>3.1 基本思想</strong><br>快速排序（Quicksort）是对冒泡排序的一种改进，借用了分治的思想，由 C. A. R. Hoare 在 1962 年提出。它的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</p><p><strong>3.2 算法描述</strong><br>快速排序使用分治策略来把一个序列（list）分为两个子序列（sub-lists）。步骤为：</p><p>①. 从数列中挑出一个元素，称为” 基准”（pivot）。</p><p>②. 重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（相同的数可以到任一边）。在这个分区结束之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。</p><p>③. 递归地（recursively）把小于基准值元素的子数列和大于基准值元素的子数列排序。</p><p>递归到最底部时，数列的大小是零或一，也就是已经排序好了。这个算法一定会结束，因为在每次的迭代（iteration）中，它至少会把一个元素摆到它最后的位置去。<br><img src="https://user-gold-cdn.xitu.io/2018/9/10/165c220dad2f209c?imageslim" alt=""></p><p><strong>3.3 代码实现</strong><br>①. 挖坑法 用伪代码描述如下：</p><p>（1）low = L; high = R; 将基准数挖出形成第一个坑 a[low]。</p><p>（2）high–，由后向前找比它小的数，找到后挖出此数填前一个坑 a[low] 中。</p><p>（3）low++，由前向后找比它大的数，找到后也挖出此数填到前一个坑 a[high] 中。</p><p>（4）再重复执行②，③二步，直到 low==high，将基准数填入 a[low] 中。</p><p>举例说明： 一个无序数组：[4, 3, 7, 5, 10, 9, 1, 6, 8, 2]</p><p>（1）随便先挖个坑，就在第一个元素（基准元素）挖坑，挖出来的 “萝卜”（第一个元素 4）在 “篮子”（临时变量）里备用。 挖完之后的数组是这样：[ 坑, 3, 7, 5, 10, 9, 1, 6, 8,2]</p><p>（2）挖右坑填左坑：从右边开始，找个比 “萝卜”（元素 4）小的元素，挖出来，填到前一个坑里面。 填坑之后：[ 2, 3, 7, 5, 10, 9, 1, 6, 8, 坑]</p><p>（3）挖左坑填右坑：从左边开始，找个比 “萝卜”（元素 4）大的元素，挖出来，填到右边的坑里面。 填坑之后：[ 2, 3, 坑, 5, 10, 9, 1, 6, 8, 7]</p><p>（4）挖右坑填左坑：从右边开始，找个比 “萝卜”（元素 4）小的元素，挖出来，填到前一个坑里面。 填坑之后：[ 2, 3, 1, 5, 10, 9, 坑, 6, 8, 7]</p><p>（5）挖左坑填右坑：从左边开始，找个比 “萝卜”（元素 4）大的元素，挖出来，填到右边的坑里面。 填坑之后：[ 2, 3, 1, 坑, 10, 9, 5, 6, 8, 7]</p><p>（6）挖右坑填左坑：从右边开始，找个比 “萝卜”（元素 4）小的元素，挖出来，填到前一个坑里面，这一次找坑的过程中，找到了上一次挖的坑了，说明可以停了，用篮子里的的萝卜，把这个坑填了就行了，并且返回这个坑的位置，作为分而治之的中轴线。 填坑之后：[ 2, 3, 1, 4, 10, 9, 5, 6, 8, 7]</p><p>上面的步骤中，第 2，4, 6 其实都是一样的操作，3 和 5 的操作也是一样的，代码如下：</p><pre class=" language-java"><code class="language-java">  <span class="token comment" spellcheck="true">/**     *  快速排序（挖坑法递归）     * @param arr   待排序数组     * @param low   左边界     * @param high  右边界     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span><span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> low<span class="token punctuation">,</span> <span class="token keyword">int</span> high<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>arr <span class="token operator">==</span> null <span class="token operator">||</span> arr<span class="token punctuation">.</span>length <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>low <span class="token operator">>=</span> high<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> left <span class="token operator">=</span> low<span class="token punctuation">;</span>        <span class="token keyword">int</span> right <span class="token operator">=</span> high<span class="token punctuation">;</span>        <span class="token keyword">int</span> temp <span class="token operator">=</span> arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//挖坑1：保存基准的值</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">>=</span> temp<span class="token punctuation">)</span> <span class="token punctuation">{</span>                right<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//坑2：从后向前找到比基准小的元素，插入到基准位置坑1中</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> temp<span class="token punctuation">)</span> <span class="token punctuation">{</span>                left <span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            arr<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//坑3：从前往后找到比基准大的元素，放到刚才挖的坑2中</span>        <span class="token punctuation">}</span>        arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//基准值填补到坑3中，准备分治递归快排</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Sorting: "</span> <span class="token operator">+</span> Arrays<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">sort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> low<span class="token punctuation">,</span> left<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">sort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> left <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> high<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>②. 左右指针法</p><p>用伪代码描述如下：</p><p>（1）low = L; high = R; 选取 a[low] 作为关键字记录为 key。</p><p>（2）high–，由后向前找比它小的数</p><p>（3）low++，由前向后找比它大的数</p><p>（4）交换第（2）、（3）步找到的数</p><p>（5）重复（2）、（3），一直往后找，直到 left 和 right 相遇，这时将 key 和 a[low] 交换位置。</p><p>代码如下：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 快速排序 * Created by zhoujunfu on 2018/8/6. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">QuickSort</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 快速排序（左右指针法）     * @param arr 待排序数组     * @param low 左边界     * @param high 右边界     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">sort2</span><span class="token punctuation">(</span><span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> low<span class="token punctuation">,</span> <span class="token keyword">int</span> high<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>arr <span class="token operator">==</span> null <span class="token operator">||</span> arr<span class="token punctuation">.</span>length <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>low <span class="token operator">>=</span> high<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> left <span class="token operator">=</span> low<span class="token punctuation">;</span>        <span class="token keyword">int</span> right <span class="token operator">=</span> high<span class="token punctuation">;</span>        <span class="token keyword">int</span> key <span class="token operator">=</span> arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">>=</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>                right<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>                left<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> left<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> low<span class="token punctuation">,</span> left<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Sorting: "</span> <span class="token operator">+</span> Arrays<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">sort2</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> low<span class="token punctuation">,</span> left <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">sort2</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> left <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> high<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> low<span class="token punctuation">,</span> <span class="token keyword">int</span> high<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> tmp <span class="token operator">=</span> arr<span class="token punctuation">[</span>low<span class="token punctuation">]</span><span class="token punctuation">;</span>        arr<span class="token punctuation">[</span>low<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>high<span class="token punctuation">]</span><span class="token punctuation">;</span>        arr<span class="token punctuation">[</span>high<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><strong>3.4 算法效率</strong><br>快速排序并不稳定，快速排序每次交换的元素都有可能不是相邻的, 因此它有可能打破原来值为相同的元素之间的顺序。</p><table><thead><tr><th>平均时间复杂度</th><th>最好情况</th><th>最坏情况</th><th>空间复杂度</th></tr></thead><tbody><tr><td>O(nlogn)</td><td>O(nlogn)</td><td>O(n&sup2;)</td><td>O(1)</td></tr></tbody></table><h5 id="4-直接插入排序"><a href="#4-直接插入排序" class="headerlink" title="4. 直接插入排序"></a>4. 直接插入排序</h5><p><strong>4.1 基本思想</strong><br>直接插入排序的基本思想是：将数组中的所有元素依次跟前面已经排好的元素相比较，如果选择的元素比已排序的元素小，则交换，直到全部元素都比较过为止。<br><img src="https://user-gold-cdn.xitu.io/2018/9/10/165c25fe0f393246?imageslim" alt=""></p><p><strong>4.2 算法描述</strong><br>一般来说，插入排序都采用 in-place 在数组上实现。具体算法描述如下：</p><p>①. 从第一个元素开始，该元素可以认为已经被排序</p><p>②. 取出下一个元素，在已经排序的元素序列中从后向前扫描</p><p>③. 如果该元素（已排序）大于新元素，将该元素移到下一位置</p><p>④. 重复步骤 3，直到找到已排序的元素小于或者等于新元素的位置</p><p>⑤. 将新元素插入到该位置后</p><p>⑥. 重复步骤②~⑤</p><p><img src="https://user-gold-cdn.xitu.io/2018/9/10/165c260584694ff9?imageslim" alt=""></p><p><strong>4.3 代码实现</strong><br>提供两种写法，一种是移位法，一种是交换法。移位法是完全按照以上算法描述实，再插入过程中将有序序列中比待插入数字大的数据向后移动，由于移动时会覆盖待插入数据，所以需要额外的临时变量保存待插入数据，代码实现如下：</p><p>①. 移位法：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token operator">==</span> null <span class="token operator">||</span> a<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> a<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> temp <span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 先取出待插入数据保存，因为向后移位过程中会把覆盖掉待插入数</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> a<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 如果待是比待插入数据大，就后移</span>                a<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                j<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            a<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 找到比待插入数据小的位置，将待插入数据插入</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><p>而交换法不需求额外的保存待插入数据，通过不停的向前交换带插入数据，类似冒泡法，直到找到比它小的值，也就是待插入数据找到了自己的位置。</p><p>②. 交换法：</p><pre class=" language-java"><code class="language-java">  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">sort2</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>arr <span class="token operator">==</span> null <span class="token operator">||</span> arr<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i <span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                arr<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> arr<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">//只要大就交换操作</span>                arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                arr<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Sorting:  "</span> <span class="token operator">+</span> Arrays<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><p><strong>4.4 算法效率</strong><br>直接插入排序不是稳定的排序算法。</p><table><thead><tr><th>平均时间复杂度</th><th>最好情况</th><th>最坏情况</th><th>空间复杂度</th></tr></thead><tbody><tr><td>O(n&sup2;)</td><td>O(n)</td><td>O(n&sup2;)</td><td>O(1)</td></tr></tbody></table><h5 id="5-希尔排序"><a href="#5-希尔排序" class="headerlink" title="5. 希尔排序"></a>5. 希尔排序</h5><p>希尔排序，也称递减增量排序算法，1959 年 Shell 发明。是插入排序的一种高速而稳定的改进版本。</p><p>希尔排序是先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录 “基本有序” 时，再对全体记录进行依次直接插入排序。</p><p><strong>5.1 基本思想</strong><br>将待排序数组按照步长 gap 进行分组，然后将每组的元素利用直接插入排序的方法进行排序；每次再将 gap 折半减小，循环上述操作；当 gap=1 时，利用直接插入，完成排序。</p><p>可以看到步长的选择是希尔排序的重要部分。只要最终步长为 1 任何步长序列都可以工作。一般来说最简单的步长取值是初次取数组长度的一半为增量，之后每次再减半，直到增量为 1。更好的步长序列取值可以参考维基百科。</p><p><strong>5.2 算法描述</strong><br>①. 选择一个增量序列 t1，t2，…，tk，其中 ti&gt;tj，tk=1；（一般初次取数组半长，之后每次再减半，直到增量为 1）</p><p>②. 按增量序列个数 k，对序列进行 k 趟排序；</p><p>③. 每趟排序，根据对应的增量 ti，将待排序列分割成若干长度为 m 的子序列，分别对各子表进行直接插入排序。仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</p><p><img src="https://user-gold-cdn.xitu.io/2018/9/10/165c28aa1bb3ac75?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p><p>在上面这幅图中： 初始时，有一个大小为 10 的无序序列。</p><p>在第一趟排序中，我们不妨设 gap1 = N / 2 = 5，即相隔距离为 5 的元素组成一组，可以分为 5 组。</p><p>接下来，按照直接插入排序的方法对每个组进行排序。</p><p>在第二趟排序中，我们把上次的 gap 缩小一半，即 gap2 = gap1 / 2 = 2 (取整数)。这样每相隔距离为 2 的元素组成一组，可以分为 2 组。</p><p>按照直接插入排序的方法对每个组进行排序。</p><p>在第三趟排序中，再次把 gap 缩小一半，即 gap3 = gap2 / 2 = 1。 这样相隔距离为 1 的元素组成一组，即只有一组。 按照直接插入排序的方法对每个组进行排序。此时，排序已经结束。</p><p>需要注意一下的是，图中有两个相等数值的元素 5 和 5 。我们可以清楚的看到，在排序过程中，两个元素位置交换了。 所以，希尔排序是不稳定的算法。</p><p><strong>5.3 代码实现</strong>  </p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ShellSort</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> gap <span class="token operator">=</span> arr<span class="token punctuation">.</span>length <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span>gap <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span> gap <span class="token operator">=</span> gap<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">(</span>j <span class="token operator">+</span> gap<span class="token punctuation">)</span> <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//不断缩小gap，直到1为止</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">(</span>k <span class="token operator">+</span> gap<span class="token punctuation">)</span> <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> k<span class="token operator">+=</span>gap<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//使用当前gap进行组内插入排序</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">></span> arr<span class="token punctuation">[</span>k<span class="token operator">+</span>gap<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//交换操作</span>                        arr<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">+</span> arr<span class="token punctuation">[</span>k<span class="token operator">+</span>gap<span class="token punctuation">]</span><span class="token punctuation">;</span>                        arr<span class="token punctuation">[</span>k<span class="token operator">+</span>gap<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">-</span> arr<span class="token punctuation">[</span>k<span class="token operator">+</span>gap<span class="token punctuation">]</span><span class="token punctuation">;</span>                        arr<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">-</span> arr<span class="token punctuation">[</span>k<span class="token operator">+</span>gap<span class="token punctuation">]</span><span class="token punctuation">;</span>                        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"    Sorting:  "</span> <span class="token operator">+</span> Arrays<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>5.4 算法效率<br>不稳定排序算法，希尔排序第一个突破 O(n2) 的排序算法；是简单插入排序的改进版；它与插入排序的不同之处在于，它会优先比较距离较远的元素，直接插入排序是稳定的；而希尔排序是不稳定的，希尔排序的时间复杂度和步长的选择有关，常用的是 Shell 增量排序，也就是 N/2 的序列，Shell 增量序列不是最好的增量序列，其他还有 Hibbard 增量序列、Sedgewick 增量序列等，具体可以参考，<a href="https://link.juejin.im?target=https%3A%2F%2Fblog.csdn.net%2FFoliciatarier%2Farticle%2Fdetails%2F53891144" title="希尔排序增量序列简介" target="_blank" rel="noopener">希尔排序增量序列简介</a>。</p><h5 id="6-选择排序"><a href="#6-选择排序" class="headerlink" title="6. 选择排序"></a>6. 选择排序</h5><p><strong>6.1 基本思想</strong><br>在未排序序列中找到最小（大）元素，存放到未排序序列的起始位置。在所有的完全依靠交换去移动元素的排序方法中，选择排序属于非常好的一种。</p><p><strong>6.2 算法描述</strong><br>①. 从待排序序列中，找到关键字最小的元素；</p><p>②. 如果最小元素不是待排序序列的第一个元素，将其和第一个元素互换；</p><p>③. 从余下的 N - 1 个元素中，找出关键字最小的元素，重复①、②步，直到排序结束。<br><img src="https://user-gold-cdn.xitu.io/2018/9/10/165c2d4fd254df47?imageslim" alt=""></p><p><strong>6.3 代码实现</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SelectSort</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> min <span class="token operator">=</span> i<span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> j <span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//选出之后待排序中值最小的位置</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> arr<span class="token punctuation">[</span>min<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    min <span class="token operator">=</span> j<span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>min <span class="token operator">!=</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>                arr<span class="token punctuation">[</span>min<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> arr<span class="token punctuation">[</span>min<span class="token punctuation">]</span><span class="token punctuation">;</span>                arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>min<span class="token punctuation">]</span> <span class="token operator">-</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                arr<span class="token punctuation">[</span>min<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>min<span class="token punctuation">]</span> <span class="token operator">-</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><p><strong>6.4 算法效率</strong><br>不稳定排序算法，选择排序的简单和直观名副其实，这也造就了它出了名的慢性子，无论是哪种情况，哪怕原数组已排序完成，它也将花费将近 n²/2 次遍历来确认一遍。 唯一值得高兴的是，它并不耗费额外的内存空间。</p><table><thead><tr><th>平均时间复杂度</th><th>最好情况</th><th>最坏情况</th><th>空间复杂度</th></tr></thead><tbody><tr><td>O(n&sup2;)</td><td>O(n&sup2;)</td><td>O(n&sup2;)</td><td>O(1)</td></tr></tbody></table><h5 id="7-归并排序"><a href="#7-归并排序" class="headerlink" title="7. 归并排序"></a>7. 归并排序</h5><p>归并排序是建立在归并操作上的一种有效的排序算法，1945 年由约翰 冯 诺伊曼首次提出。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用，且各层分治递归可以同时进行。</p><p><strong>7.1 基本思想</strong><br>归并排序算法是将两个（或两个以上）有序表合并成一个新的有序表，即把待排序序列分为若干个子序列，每个子序列是有序的。然后再把有序子序列合并为整体有序序列。<br><img src="https://user-gold-cdn.xitu.io/2018/9/10/165c2d849cf3a4b6?imageslim" alt=""><br><strong>7.2 算法描述</strong><br>采用递归法： ①. 将序列每相邻两个数字进行归并操作，形成 floor(n/2) 个序列，排序后每个序列包含两个元素；</p><p>②. 将上述序列再次归并，形成 floor(n/4) 个序列，每个序列包含四个元素；</p><p>③. 重复步骤②，直到所有元素排序完毕<br><img src="https://user-gold-cdn.xitu.io/2018/9/10/165c2d88eb326ec1?imageslim" alt=""></p><p><strong>7.3 代码实现</strong>  </p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>fufu<span class="token punctuation">.</span>algorithm<span class="token punctuation">.</span>sort<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Arrays<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * Created by zhoujunfu on 2018/8/10. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MergeSort</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">sort</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">.</span>length <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> a<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> num <span class="token operator">=</span> a<span class="token punctuation">.</span>length <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> left <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">copyOfRange</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> num<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> right <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">copyOfRange</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> num<span class="token punctuation">,</span> a<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">mergeTwoArray</span><span class="token punctuation">(</span><span class="token function">sort</span><span class="token punctuation">(</span>left<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">sort</span><span class="token punctuation">(</span>right<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">mergeTwoArray</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>a<span class="token punctuation">.</span>length <span class="token operator">+</span> b<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 申请额外空间保存归并之后数据</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> a<span class="token punctuation">.</span>length <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;</span> b<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//选取两个序列中的较小值放入新数组</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> b<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                result<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                result<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> b<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> a<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//序列a中多余的元素移入新数组</span>            result<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">&lt;</span> b<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//序列b中多余的元素移入新数组</span>            result<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> b<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> result<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> b <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Arrays<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token function">sort</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><strong>7.4 算法效率</strong>   </p><table><thead><tr><th>平均时间复杂度</th><th>最好情况</th><th>最坏情况</th><th>空间复杂度</th></tr></thead><tbody><tr><td>O(nlogn)</td><td>O(nlogn)</td><td>O(nlogn)</td><td>O(n)</td></tr></tbody></table><p>稳定排序算法，从效率上看，归并排序可算是排序算法中的” 佼佼者”. 假设数组长度为 n，那么拆分数组共需 logn, 又每步都是一个普通的合并子数组的过程，时间复杂度为 O(n)， 故其综合时间复杂度为 O(nlogn)。另一方面， 归并排序多次递归过程中拆分的子数组需要保存在内存空间， 其空间复杂度为 O(n)。 和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是 O(nlogn）的时间复杂度。代价是需要额外的内存空间。</p><h5 id="8-基数排序"><a href="#8-基数排序" class="headerlink" title="8. 基数排序"></a>8. 基数排序</h5><p>基数排序（Radix sort）是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。</p><p><strong>8.1 基本思想</strong><br>将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后，数列就变成一个有序序列。</p><p>基数排序按照优先从高位或低位来排序有两种实现方案：<br><em><strong>MSD（Most significant digital）</strong></em> 从最左侧高位开始进行排序。先按 k1 排序分组, 同一组中记录, 关键码 k1 相等, 再对各组按 k2 排序分成子组, 之后, 对后面的关键码继续这样的排序分组, 直到按最次位关键码 kd 对各子组排序后. 再将各组连接起来, 便得到一个有序序列。MSD 方式适用于位数多的序列。</p><p><em><strong>LSD（Least significant digital）</strong></em> 从最右侧低位开始进行排序。先从 kd 开始排序，再对 kd-1 进行排序，依次重复，直到对 k1 排序后便得到一个有序序列。LSD 方式适用于位数少的序列。</p><p>下图是 LSD 基数排序的示意图：<br><img src="https://user-gold-cdn.xitu.io/2018/9/11/165c75b70ba878f4?imageslim" alt=""></p><p><strong>8.2 算法描述</strong><br>以 LSD 为例，从最低位开始，具体算法描述如下：</p><p>①. 取得数组中的最大数，并取得位数； ②. arr 为原始数组，从最低位开始取每个位组成 radix 数组； ③. 对 radix 进行计数排序（利用计数排序适用于小范围数的特点）；</p><p><strong>8.3 代码实现</strong><br>基数排序：通过序列中各个元素的值，对排序的 N 个元素进行若干趟的 “分配” 与“收集”来实现排序。</p><p><em><strong>分配</strong></em>：我们将 L[i] 中的元素取出，首先确定其个位上的数字，根据该数字分配到与之序号相同的桶中</p><p><em><strong>收集</strong></em>：当序列中所有的元素都分配到对应的桶中，再按照顺序依次将桶中的元素收集形成新的一个待排序列 L[]。对新形成的序列 L[] 重复执行分配和收集元素中的十位、百位… 直到分配完该序列中的最高位，则排序结束</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>fufu<span class="token punctuation">.</span>algorithm<span class="token punctuation">.</span>sort<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Arrays<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * Created by zhoujunfu on 2018/9/11. * 基数排序LSD */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RadixSort</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token function">sort</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token operator">==</span> null <span class="token operator">||</span> a<span class="token punctuation">.</span>length <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> max <span class="token operator">=</span> a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span>a<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> max<span class="token punctuation">)</span> <span class="token punctuation">{</span>                max <span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"max, "</span> <span class="token operator">+</span> max<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> maxDigit <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>max <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            max <span class="token operator">=</span> max <span class="token operator">/</span> <span class="token number">10</span><span class="token punctuation">;</span>            maxDigit<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"maxDigit, "</span> <span class="token operator">+</span> maxDigit<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> buckets <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">[</span>a<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> base <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//从低位到高位，对每一位遍历，将所有元素分配到桶中</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> maxDigit<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> bucketLen <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//存储各个桶中存储元素的数量</span>            <span class="token comment" spellcheck="true">//收集：将不同桶里数据挨个捞出来,为下一轮高位排序做准备,由于靠近桶底的元素排名靠前,因此从桶底先捞</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> a<span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">int</span> whichBucket <span class="token operator">=</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">%</span> base<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token punctuation">(</span>base <span class="token operator">/</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                buckets<span class="token punctuation">[</span>whichBucket<span class="token punctuation">]</span><span class="token punctuation">[</span>bucketLen<span class="token punctuation">[</span>whichBucket<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                bucketLen<span class="token punctuation">[</span>whichBucket<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//收集：将不同桶里数据挨个捞出来,为下一轮高位排序做准备,由于靠近桶底的元素排名靠前,因此从桶底先捞</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> l <span class="token operator">&lt;</span> buckets<span class="token punctuation">.</span>length<span class="token punctuation">;</span> l<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> m <span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> m <span class="token operator">&lt;</span> bucketLen<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">;</span> m<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    a<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> buckets<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Sorting: "</span> <span class="token operator">+</span> Arrays<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            base <span class="token operator">*=</span> <span class="token number">10</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><strong>8.4 算法效率</strong><br>基数排序不改变相同元素之间的相对顺序，因此它是稳定的排序算法，以下是基数排序算法复杂度：</p><table><thead><tr><th>平均时间复杂度</th><th>最好情况</th><th>最坏情况</th><th>空间复杂度</th></tr></thead><tbody><tr><td>O(d*(n+r))</td><td>O(d*(n+r))</td><td>O(d*(n+r))</td><td>O(n+r)</td></tr></tbody></table><p>其中，d 为位数，r 为基数，n 为原数组个数。在基数排序中，因为没有比较操作，所以在复杂上，最好的情况与最坏的情况在时间上是一致的，均为 O(d*(n + r))。</p><p>基数排序更适合用于对时间, 字符串等这些整体权值未知的数据进行排序，适用于。</p><p>(1) 数据范围较小，建议在小于 1000</p><p>(2) 每个数值都要大于等于 0</p><p>基数排序 vs 计数排序 vs 桶排序</p><p>这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异：</p><p>基数排序：根据键值的每位数字来分配桶<br>计数排序：每个桶只存储单一键值<br>桶排序：每个桶存储一定范围的数值</p><p>计数排序和桶排序在这篇文章里具体就不写了，有需要的可以自行百度。</p><h5 id="9-堆排序"><a href="#9-堆排序" class="headerlink" title="9. 堆排序"></a>9. 堆排序</h5><p>看堆排序之前先介绍一下面几个概念：</p><p>完全二叉树： 若设二叉树的深度为 h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第 h 层所有的结点都连续集中在最左边，这就是完全二叉树，很好理解如下图所示。<br><img src="/images/pasted-56.png" alt="upload successful"><br>堆： 堆是具有以下性质的完全二叉树，每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。如下图：<br><img src="/images/pasted-57.png" alt="upload successful"><br>同时，我们对堆中的结点按层进行编号，将这种逻辑结构映射到数组中就是下面这个样子：<br><img src="/images/pasted-58.png" alt="upload successful"><br>该数组从逻辑上讲就是一个堆结构，我们用简单的公式来描述一下堆的定义就是：</p><p>大顶堆：arr[i] &gt;= arr[2i+1] &amp;&amp; arr[i] &gt;= arr[2i+2]</p><p>小顶堆：arr[i] &lt;= arr[2i+1] &amp;&amp; arr[i] &lt;= arr[2i+2]</p><p>ok，了解了这些定义。接下来，我们来看看堆排序的基本思想及基本步骤：<br><strong>9.1 基本思想</strong><br>堆排序的基本思想是：将待排序序列构造成一个大顶堆，此时，整个序列的最大值就是堆顶的根节点。将其与末尾元素进行交换，此时末尾就为最大值。然后将剩余 n-1 个元素重新构造成一个堆，这样会得到 n 个元素的次小值。如此反复执行，便能得到一个有序序列了。</p><p><strong>9.2 算法描述</strong><br>步骤一 构造初始堆。将给定无序序列构造成一个大顶堆（一般升序采用大顶堆，降序采用小顶堆)。</p><ol><li>假设给定无序序列结构如下<br><img src="/images/pasted-59.png" alt="upload successful"></li><li>此时我们从最后一个非叶子结点开始（叶结点自然不用调整，第一个非叶子结点 arr.length/2-1=5/2-1=1，也就是下面的 6 结点），从左至右，从下至上进行调整。<br><img src="/images/pasted-60.png" alt="upload successful"></li><li>找到第二个非叶节点 4，由于 [4,9,8] 中 9 元素最大，4 和 9 交换<br><img src="/images/pasted-61.png" alt="upload successful"><br>这时，交换导致了子根 [4,5,6] 结构混乱，继续调整，[4,5,6]中 6 最大，交换 4 和 6。<br><img src="/images/pasted-62.png" alt="upload successful"><br>此时，我们就将一个无需序列构造成了一个大顶堆。</li></ol><p>步骤二 将堆顶元素与末尾元素进行交换，使末尾元素最大。然后继续调整堆，再将堆顶元素与末尾元素交换，得到第二大元素。如此反复进行交换、重建、交换。<br><img src="/images/pasted-63.png" alt="upload successful"><br>b. 重新调整结构，使其继续满足堆定义<br><img src="/images/pasted-64.png" alt="upload successful"><br>c. 再将堆顶元素 8 与末尾元素 5 进行交换，得到第二大元素 8.<br><img src="/images/pasted-65.png" alt="upload successful"><br>后续过程，继续进行调整，交换，如此反复进行，最终使得整个序列有序<br><img src="/images/pasted-66.png" alt="upload successful"><br>再简单总结下堆排序的基本思路：</p><p>  a. 将无需序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆;</p><p>  b. 将堆顶元素与末尾元素交换，将最大元素 “沉” 到数组末端;</p><p>  c. 重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整 + 交换步骤，直到整个序列有序。      </p><p><strong>9.3 算法实现</strong>  </p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>fufu<span class="token punctuation">.</span>algorithm<span class="token punctuation">.</span>sort<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Arrays<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * Created by zhoujunfu on 2018/9/26. */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HeapSort</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String <span class="token punctuation">[</span><span class="token punctuation">]</span>args<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">int</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>arr <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token function">sort</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Arrays<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>arr<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//1.构建大顶堆</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>arr<span class="token punctuation">.</span>length<span class="token operator">/</span><span class="token number">2</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">>=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//从第一个非叶子结点从下至上，从右至左调整结构</span>            <span class="token function">adjustHeap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span>i<span class="token punctuation">,</span>arr<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//2.调整堆结构+交换堆顶元素与末尾元素</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span>arr<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//将堆顶元素与末尾元素进行交换</span>            <span class="token function">adjustHeap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//重新对堆进行调整</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 调整大顶堆（仅是调整过程，建立在大顶堆已构建的基础上）     * @param arr     * @param i     * @param length     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">adjustHeap</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>arr<span class="token punctuation">,</span><span class="token keyword">int</span> i<span class="token punctuation">,</span><span class="token keyword">int</span> length<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">int</span> temp <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//先取出当前元素i</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token operator">=</span>i<span class="token operator">*</span><span class="token number">2</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>k<span class="token operator">&lt;</span>length<span class="token punctuation">;</span>k<span class="token operator">=</span>k<span class="token operator">*</span><span class="token number">2</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//从i结点的左子结点开始，也就是2i+1处开始</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>k<span class="token operator">+</span><span class="token number">1</span><span class="token operator">&lt;</span>length <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token operator">&lt;</span>arr<span class="token punctuation">[</span>k<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//如果左子结点小于右子结点，k指向右子结点</span>                k<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">></span>temp<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//如果子节点大于父节点，将子节点值赋给父节点（不用进行交换）</span>                arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span>                i <span class="token operator">=</span> k<span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//将temp值放到最终的位置</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 交换元素     * @param arr     * @param a     * @param b     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>arr<span class="token punctuation">,</span><span class="token keyword">int</span> a <span class="token punctuation">,</span><span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">int</span> temp<span class="token operator">=</span>arr<span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">;</span>        arr<span class="token punctuation">[</span>a<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>b<span class="token punctuation">]</span><span class="token punctuation">;</span>        arr<span class="token punctuation">[</span>b<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><strong>9.4 算法效率</strong><br>由于堆排序中初始化堆的过程比较次数较多, 因此它不太适用于小序列。同时由于多次任意下标相互交换位置, 相同元素之间原本相对的顺序被破坏了, 因此, 它是不稳定的排序。</p><p>①. 建立堆的过程, 从 length/2 一直处理到 0, 时间复杂度为 O(n);</p><p>②. 调整堆的过程是沿着堆的父子节点进行调整, 执行次数为堆的深度, 时间复杂度为 O(lgn);</p><p>③. 堆排序的过程由 n 次第②步完成, 时间复杂度为 O(nlgn).</p><table><thead><tr><th>平均时间复杂度</th><th>最好情况</th><th>最坏情况</th><th>空间复杂度</th></tr></thead><tbody><tr><td>O(nlogn)</td><td>O(nlogn)</td><td>O(nlogn)</td><td>O(1)</td></tr></tbody></table><h5 id="10-总结"><a href="#10-总结" class="headerlink" title="10. 总结"></a>10. 总结</h5><p><img src="/images/pasted-67.png" alt="upload successful"><br>从时间复杂度来说：</p><p>(1). 平方阶 O(n²) 排序：各类简单排序：直接插入、直接选择和冒泡排序；</p><p>(2). 线性对数阶 O(nlog₂n) 排序：快速排序、堆排序和归并排序；</p><p>(3). O(n1+§)) 排序，§ 是介于 0 和 1 之间的常数：希尔排序</p><p>(4). 线性阶 O(n) 排序：基数排序，此外还有桶、箱排序。</p><p>时间复杂度极限：</p><p>当被排序的数有一些性质的时候（比如是整数，比如有一定的范围），排序算法的复杂度是可以小于 O(nlgn) 的。比如：</p><p>计数排序 复杂度 O(k+n) 要求：被排序的数是 0~k 范围内的整数</p><p>基数排序 复杂度 O(d(k+n) ) 要求：d 位数，每个数位有 k 个取值</p><p>桶排序 复杂度 O(n) （平均） 要求：被排序数在某个范围内，并且服从均匀分布</p><p>但是，当被排序的数不具有任何性质的时候，一般使用基于比较的排序算法，而基于比较的排序算法时间复杂度的下限必须是 O(nlgn) 。参考很多高效排序算法的代价是 nlogn，难道这是排序算法的极限了吗？</p><p>说明 当原表有序或基本有序时，直接插入排序和冒泡排序将大大减少比较次数和移动记录的次数，时间复杂度可降至 O（n）；</p><p>而快速排序则相反，当原表基本有序时，将蜕化为冒泡排序，时间复杂度提高为 O（n2）；</p><p>原表是否有序，对简单选择排序、堆排序、归并排序和基数排序的时间复杂度影响不大。</p><h5 id="11-参考资料"><a href="#11-参考资料" class="headerlink" title="11. 参考资料"></a>11. 参考资料</h5><p><a href="href=&quot;https://link.juejin.im?target=https%3A%2F%2Fitimetraveler.github.io%2F2017%2F07%2F18%2F%25E5%2585%25AB%25E5%25A4%25A7%25E6%258E%2592%25E5%25BA%258F%25E7%25AE%2597%25E6%25B3%2595%25E6%2580%25BB%25E7%25BB%2593%25E4%25B8%258Ejava%25E5%25AE%259E%25E7%258E%25B0%2F%23%25E6%2580%25BB%25E7%25BB%2593&quot;">八大排序算法总结与 java 实现</a><br><a href="href=&quot;https://link.juejin.im?target=https%3A%2F%2Fwww.cnblogs.com%2Fchengxiao%2Fp%2F6129630.html&quot;">图解排序算法 (三) 之堆排序</a></p><blockquote><p>原文地址 <a href="https://juejin.im/post/5b95da8a5188255c775d8124?utm_source=gold_browser_extension" target="_blank" rel="noopener">https://juejin.im/post/5b95da8a5188255c775d8124?utm_source=gold_browser_extension</a></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Redis缓存穿透、缓存雪崩的分析及解决方案</title>
      <link href="/2018/11/21/redis-huan-cun-chuan-tou-huan-cun-xue-beng-de-fen-xi-ji-jie-jue-fang-an/"/>
      <url>/2018/11/21/redis-huan-cun-chuan-tou-huan-cun-xue-beng-de-fen-xi-ji-jie-jue-fang-an/</url>
      
        <content type="html"><![CDATA[<h4 id="什么是缓存击穿"><a href="#什么是缓存击穿" class="headerlink" title="什么是缓存击穿"></a>什么是缓存击穿</h4><p>缓存击穿是查询数据库中不存在的数据，如果有用户恶意模拟请求很多缓存中不存在的数据，由于缓存中都没有，导致这些请求短时间内直接落在了DB上，对DB产生压力，导致数据库异常。</p><h5 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h5><p><strong>布隆过滤器</strong></p><p>最常见的则是采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被这个bitmap拦截掉，从而避免了对底层存储系统的查询压力。<br>bloomfilter就类似于一个hash set，用于快速判某个元素是否存在于集合中，其典型的应用场景就是快速判断一个key是否存在于某容器，不存在就直接返回。布隆过滤器的关键就在于hash算法和容器大小。<br>maven工程引入guava包：</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">></span></span>       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>           <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.google.guava<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>           <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>guava<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>           <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>23.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">></span></span>  </code></pre><p>redis实现代码    </p><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> String <span class="token function">getByKey</span><span class="token punctuation">(</span>String key<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 通过key获取value</span>        String value <span class="token operator">=</span> redis<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>StringUtil<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>bloomFilter<span class="token punctuation">.</span><span class="token function">mightContain</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                value <span class="token operator">=</span> xxxService<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>                redis<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> value<span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> null<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> value<span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>布隆过滤器判断一个数是否存在于一个百万级别的集合中，只要0.2ms就可以完成，性能极佳。BloomFilter的默认的容错率是0.03。<br>要注意的是：误判率越低，底层维护的数组越长，占用空间越大。因此，误判率实际取值，根据服务器所能够承受的负载来决定；布隆过滤器不支持删除操作。</p><p><strong>使用互斥锁</strong></p><p>该方法是比较普遍的做法，在根据key获得的value值为空时加锁，再从数据库加载，加载完成后释放锁。若其他线程获取锁失败时睡眠一段时间后重试。<br>单机环境用并发包的普通锁（synchronized、Lock）类型就行，集群环境则使用分布式锁(Redis的setnx)<br>集群环境Redis分布式锁实现如下</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> String <span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>    String value <span class="token operator">=</span> redis<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>value <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//代表缓存值过期</span>        <span class="token comment" spellcheck="true">//设置3min的超时，防止del操作失败的时候，下次缓存过期一直不能load db</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>redis<span class="token punctuation">.</span><span class="token function">setnx</span><span class="token punctuation">(</span>key_mutex<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span> <span class="token operator">*</span> <span class="token number">60</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//代表设置成功</span>            value <span class="token operator">=</span> db<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>            redis<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> expire_secs<span class="token punctuation">)</span><span class="token punctuation">;</span>            redis<span class="token punctuation">.</span><span class="token function">del</span><span class="token punctuation">(</span>key_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//其他线程休息50毫秒后重试</span>            <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> value<span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><strong>将空值放入缓存</strong></p><p>如果查询数据库也为空,也设置一个默认空值存放到缓存，并设置一定的失效时间（不超过五分钟），这样第二次到缓存中获取就有返回值，而不会继续访问数据库，这种办法最简单粗暴。  </p><p>缓存空对象会有两个问题：</p><p>第一，空值做了缓存，意味着缓存层中存了更多的键，需要更多的内存空间 ( 如果是攻击，问题更严重 )，比较有效的方法是针对这类数据设置一个较短的过期时间，让其自动剔除。</p><p>第二，缓存层和存储层的数据会有一段时间窗口的不一致，可能会对业务有一定影响。例如过期时间设置为 5分钟，如果此时存储层添加了这个数据，那此段时间就会出现缓存层和存储层数据的不一致，此时可以利用消息系统或者其他方式清除掉缓存层中的空对象。</p><h4 id="什么是缓存失效"><a href="#什么是缓存失效" class="headerlink" title="什么是缓存失效"></a>什么是缓存失效</h4><p>缓存雪崩是指在我们设置缓存时采用了相同的过期时间，缓存在同一时间内大量键过期，此时有多个进程就请求会全部转发到DB，导致数据库中导致连接异常。</p><h5 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h5><p><strong>使用互斥锁</strong></p><p>与解决缓存击穿问题一样用加锁排队，实现同上。</p><p><strong>在失效上加随机值</strong></p><p>还有一个简单方案就是将缓存失效时间分散开，比如我们可以在原有的失效时间基础上增加一个随机值，比如1-5分钟随机，这样每一个缓存的过期时间的重复率就会降低，避免引发集体失效。</p>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>微服务架构下的分布式事务解决方案</title>
      <link href="/2018/11/17/a-li-wei-fu-wu-jia-gou-xia-de-fen-bu-shi-shi-wu-jie-jue-fang-an/"/>
      <url>/2018/11/17/a-li-wei-fu-wu-jia-gou-xia-de-fen-bu-shi-shi-wu-jie-jue-fang-an/</url>
      
        <content type="html"><![CDATA[<h5 id="1-微服务的发展"><a href="#1-微服务的发展" class="headerlink" title="1 微服务的发展"></a>1 微服务的发展</h5><p>微服务倡导将复杂的单体应用拆分为若干个功能简单、松耦合的服务，这样可以降低开发难度、增强扩展性、便于敏捷开发。当前被越来越多的开发者推崇，很多互联网行业巨头、开源社区等都开始了微服务的讨论和实践。Hailo有160个不同服务构成，NetFlix有大约600个服务。国内方面，阿里巴巴、腾讯、360、京东、58同城等很多互联网公司都进行了微服务化实践。当前微服务的开发框架也非常多，比较著名的有Dubbo、SpringCloud、thrift 、grpc等。</p><h5 id="2-微服务落地存在的问题"><a href="#2-微服务落地存在的问题" class="headerlink" title="2 微服务落地存在的问题"></a>2 微服务落地存在的问题</h5><p>虽然微服务现在如火如荼，但对其实践其实仍处于探索阶段。很多中小型互联网公司，鉴于经验、技术实力等问题，微服务落地比较困难。如著名架构师Chris Richardson所言，目前存在的主要困难有如下几方面：</p><p>1）单体应用拆分为分布式系统后，进程间的通讯机制和故障处理措施变的更加复杂。</p><p>2）系统微服务化后，一个看似简单的功能，内部可能需要调用多个服务并操作多个数据库实现，服务调用的分布式事务问题变的非常突出。</p><p>3）微服务数量众多，其测试、部署、监控等都变的更加困难。</p><p>随着RPC框架的成熟，第一个问题已经逐渐得到解决。例如dubbo可以支持多种通讯协议，springcloud可以非常好的支持restful调用。对于第三个问题，随着docker、devops技术的发展以及各公有云paas平台自动化运维工具的推出，微服务的测试、部署与运维会变得越来越容易。</p><p>而对于第二个问题，现在还没有通用方案很好的解决微服务产生的事务问题。分布式事务已经成为微服务落地最大的阻碍，也是最具挑战性的一个技术难题。 </p><h5 id="3-传统分布式事务解决方案与适用场景"><a href="#3-传统分布式事务解决方案与适用场景" class="headerlink" title="3 传统分布式事务解决方案与适用场景"></a>3 传统分布式事务解决方案与适用场景</h5><h6 id="3-1-基于-XA-协议的两阶段提交方案"><a href="#3-1-基于-XA-协议的两阶段提交方案" class="headerlink" title="3.1 基于 XA 协议的两阶段提交方案"></a>3.1 基于 XA 协议的两阶段提交方案</h6><p>交易中间件与数据库通过 XA 接口规范，使用两阶段提交来完成一个全局事务， XA 规范的基础是两阶段提交协议。<br><img src="/images/pasted-27.png" alt="upload successful"><br>第一阶段是表决阶段，所有参与者都将本事务能否成功的信息反馈发给协调者；第二阶段是执行阶段，协调者根据所有参与者的反馈，通知所有参与者，步调一致地在所有分支上提交或者回滚。</p><p><img src="/images/pasted-36.png" alt="upload successful"><br> XA 协议资源层更普适，并且对业务几乎没有侵入，但为了适应各种业务场景使用，需要严格遵循事务 ACID 特性；服务层更接近业务，可以针对不同业务做特定的优化处理，追求更高的极限性能。</p><p>当然，并不是说 XA 协议只能作用于单个服务内部的多资源场景，跨服务的多资源场景也是可以的，只不过同样需要额外的事务传递机制。<br><img src="/images/pasted-37.png" alt="upload successful"><br>XA 协议通过每个 RM（Resource Manager，资源管理器）的本地事务隔离性来保证全局隔离，并且需要通过串行化隔离级别来保证分布式事务一致性。但是，串行化隔离级别存在一定的性能问题，如下所示：<br><img src="/images/pasted-38.png" alt="upload successful"><br>在串行化隔离级别下，会为本来不加锁的 Select 快照读操作都加上读锁，导致锁持有时间增加，并发性能进一步降低。当实现了无锁的全局一致性读取后，比如分布式 MVCC，可以大幅减少锁持有时间，并发性能会获得较大提升。</p><p>但不管怎么优化实现，分布式事务的热点数据并发性能最高就是趋近于单机本地事务。所以，无论是基于 XA 协议实现的分布式事务，还是单机本地事务，都是存在热点数据并发性能极限的。</p><p>那么 XA 协议最大的作用是什么呢？其最大的作用在于数据库资源横向扩展时，能保证多资源访问的事务属性。</p><p>当单台 RM 机器达到资源性能瓶颈，无法满足业务增长需求时，就需要横向扩展 RM 资源，形成 RM 集群。通过横向扩展资源，提升非热点数据的并发性能，这对于大体量的互联网产品来说，是至关重要的。<br><img src="/images/pasted-39.png" alt="upload successful"><br>以上图为例，假设单台 RM 的非热点数据并发性能为 100 TPS，那么 5台 RM 就是 500 TPS，就算一个分布式事务平均涉及 2 台 RM，也有 250 TPS，提升了 2.5 倍的非热点并发能力。</p><p>综上所述，基于 XA 协议实现的分布式事务并不能提升热点并发性能，其意义在于横向扩展资源提升非热点数据并发性能时，能严格保证对多资源访问的事务 ACID 特性。</p><p>至于热点数据并发性能问题，对于一般的应用来说，经过 SQL 层面一定的性能优化之后，其并发性能基本能够满足业务的需求。如果经过优化，达到性能极限之后，还不能满足，就需要上升到业务层面，根据业务特点，通过专门的业务逻辑或业务架构优化来实现。</p><p>直接在资源层实现分布式事务的另一点好处是其普适性，可以对上层业务屏蔽底层实现细节。这一点在云服务时代特别有用，云服务面对的是大量的中小企业，甚至是个人开发者，业务诉求不尽相同，普适、标准的分布式事务产品是非常有必要的，可以让开发者从底层技术细节中脱离出来，更专注于业务逻辑的实现，从而获得更高效、快速的业务发展。</p><h6 id="3-2-基于-TCC-模型的方案"><a href="#3-2-基于-TCC-模型的方案" class="headerlink" title="3.2 基于 TCC 模型的方案"></a>3.2 基于 TCC 模型的方案</h6><p>TCC方案在电商、金融领域落地较多。TCC方案其实是两阶段提交的一种改进。其将整个业务逻辑的每个分支显式的分成了Try、Confirm、Cancel三个操作。Try部分完成业务的准备工作，confirm部分完成业务的提交，cancel部分完成事务的回滚。基本原理如下图所示。<br><img src="/images/pasted-28.png" alt="upload successful"></p><p>事务开始时，业务应用会向事务协调器注册启动事务。之后业务应用会调用所有服务的try接口，完成一阶段准备。之后事务协调器会根据try接口返回情况，决定调用confirm接口或者cancel接口。如果接口调用失败，会进行重试。</p><p><img src="/images/pasted-40.png" alt="upload successful"><br>TCC 分布式事务模型直接作用于服务层。不与具体的服务框架耦合，与底层 RPC 协议无关，与底层存储介质无关，可以灵活选择业务资源的锁定粒度，减少资源锁持有时间，可扩展性好，可以说是为独立部署的 SOA 服务而设计的。</p><ul><li>跨服务的分布式事务</li></ul><p>这一部分的作用与 XA 类似，服务的拆分，也可以认为是资源的横向扩展，只不过方向不同而已。</p><p>横向扩展可能沿着两个方向发展：</p><ol><li><p>功能扩展。根据功能对数据进行分组，并将不同的功能组分布在多个不同的数据库上，这实际上就是 SOA 架构下的服务化。</p></li><li><p>数据分片，在功能组内部将数据拆分到多个数据库上，为横向扩展增加一个新的维度。</p></li></ol><p>下图简要阐释了横向数据扩展策略：<br><img src="/images/pasted-41.png" alt="upload successful"><br>横向扩展的两种方法可以同时进行运用：用户信息（Users）、产品信息（Products）与交易信息（Trans）三个不同功能组可以存储在不同的数据库中。另外，每个功能组内根据其业务量可以再拆分到多个数据库中，各功能组可以相互独立地进行扩展。</p><p>因此，TCC 的其中一个作用就是在按照功能横向扩展资源时，保证多资源访问的事务属性。</p><ul><li>两阶段拆分</li></ul><p>TCC 另一个作用就是把两阶段拆分成了两个独立的阶段，通过资源业务锁定的方式进行关联。资源业务锁定方式的好处在于，既不会阻塞其他事务在第一阶段对于相同资源的继续使用，也不会影响本事务第二阶段的正确执行。<br><img src="/images/pasted-43.png" alt="upload successful"><br>可以发现 TCC 模型进一步减少了资源锁的持有时间。同时，从理论上来说，只要业务允许，事务的第二阶段什么时候执行都可以，反正资源已经业务锁定，不会有其他事务动用该事务锁定的资源。</p><p>这对业务有什么好处呢？拿支付宝的担保交易场景来说，简化情况下，只需要涉及两个服务，交易服务和账务服务。交易作为主业务服务，账务作为从业务服务，提供 Try、Commit、Cancel 接口：</p><ol><li><p>Try 接口扣除用户可用资金，转移到预冻结资金。预冻结资金就是业务锁定方案，每个事务第二阶段只能使用本事务的预冻结资金，在第一阶段执行结束后，其他并发事务也可以继续处理用户的可用资金。</p></li><li><p>Commit 接口扣除预冻结资金，增加中间账户可用资金（担保交易不能立即把钱打给商户，需要有一个中间账户来暂存）。</p></li></ol><p>假设只有一个中间账户的情况下，每次调用支付服务的 Commit 接口，都会锁定中间账户，中间账户存在热点性能问题。</p><p>但是，在担保交易场景中，七天以后才需要将资金从中间账户划拨给商户，中间账户并不需要对外展示。因此，在执行完支付服务的第一阶段后，就可以认为本次交易的支付环节已经完成，并向用户和商户返回支付成功的结果，并不需要马上执行支付服务二阶段的 Commit 接口，等到低锋期时，再慢慢消化，异步地执行。<br><img src="/images/pasted-44.png" alt="upload successful"><br>可能部分读者认为担保交易比较特殊，其实直付交易（直接把钱打到商户账户的交易模式，Commit 接口扣除预冻结资金以后，不是转移到中间账务，而是直接转移到商户账户）也可以这样使用，只要提前告知商户，高峰期交易资金不是实时到账，但保证在一定时间之内结算完成，商户应该也是可以理解的。</p><p>这就是 TCC 分布式事务模型的二阶段异步化功能，从业务服务的第一阶段执行成功，主业务服务就可以提交完成，然后再由框架异步的执行各从业务服务的第二阶段。</p><h6 id="通用型-TCC-解决方案"><a href="#通用型-TCC-解决方案" class="headerlink" title="通用型 TCC 解决方案"></a>通用型 TCC 解决方案</h6><p>通用型 TCC 解决方案就是最典型的 TCC 分布式事务模型实现，所有从业务服务都需要参与到主业务服务的决策当中。<br><img src="/images/pasted-45.png" alt="upload successful"><br><strong>适用场景</strong><br>由于从业务服务是同步调用，其结果会影响到主业务服务的决策，因此通用型 TCC 分布式事务解决方案适用于执行时间确定且较短的业务，比如互联网金融企业最核心的三个服务：交易、支付、账务：<br><img src="/images/pasted-46.png" alt="upload successful"><br>当用户发起一笔交易时，首先访问交易服务，创建交易订单；然后交易服务调用支付服务为该交易创建支付订单，执行收款动作，最后支付服务调用账务服务记录账户流水和记账。<br>为了保证三个服务一起完成一笔交易，要么同时成功，要么同时失败，可以使用通用型 TCC 解决方案，将这三个服务放在一个分布式事务中，交易作为主业务服务，支付作为从业务服务，账务作为支付服务的嵌套从业务服务，由 TCC 模型保证事务的原子性。<br><img src="/images/pasted-47.png" alt="upload successful"><br>支付服务的 Try 接口创建支付订单，开启嵌套分布式事务，并调用账务服务的 Try 接口；账务服务在 Try 接口中冻结买家资金。一阶段调用完成后，交易完成，提交本地事务，由 TCC 框架完成分布式事务各从业务服务二阶段的调用。<br>支付服务二阶段先调用账务服务的 Confirm 接口，解冻买家资金；增加卖家可用资金。调用成功后，支付服务修改支付订单为完成状态，完成支付。<br>当支付和账务服务二阶段都调用完成后，整个分布式事务结束。</p><h6 id="异步确保型-TCC-解决方案"><a href="#异步确保型-TCC-解决方案" class="headerlink" title="异步确保型 TCC 解决方案"></a>异步确保型 TCC 解决方案</h6><p>异步确保型 TCC 解决方案的直接从业务服务是可靠消息服务，而真正的从业务服务则通过消息服务解耦，作为消息服务的消费端，异步地执行。<br><img src="/images/pasted-48.png" alt="upload successful"><br>可靠消息服务需要提供 Try，Confirm，Cancel 三个接口。Try 接口预发送，只负责持久化存储消息数据；Confirm 接口确认发送，这时才开始真正的投递消息；Cancel 接口取消发送，删除消息数据。<br>消息服务的消息数据独立存储，独立伸缩，降低从业务服务与消息系统间的耦合，在消息服务可靠的前提下，实现分布式事务的最终一致性。<br>此解决方案虽然增加了消息服务的维护成本，但由于消息服务代替从业务服务实现了 TCC 接口，从业务服务不需要任何改造，接入成本非常低。<br><strong>适用场景</strong><br>由于从业务服务消费消息是一个异步的过程，执行时间不确定，可能会导致不一致时间窗口增加。因此，异步确保性 TCC 分布式事务解决方案只适用于对最终一致性时间敏感度较低的一些被动型业务（从业务服务的处理结果不影响主业务服务的决策，只被动的接收主业务服务的决策结果）。比如会员注册服务和邮件发送服务：<br><img src="/images/pasted-49.png" alt="upload successful"><br>当用户注册会员成功，需要给用户发送一封邮件，告诉用户注册成功，并提示用户激活该会员。但要注意两点：</p><ol><li><p>如果用户注册成功，一定要给用户发送一封邮件；</p></li><li><p>如果用户注册失败，一定不能给用户发送邮件。</p></li></ol><p>因此，这同样需要会员服务和邮件服务保证原子性，要么都执行，要么都不执行。不一样的是，邮件服务只是一种被动型的业务，并不影响用户是否能够注册成功，它只需要在用户注册成功以后发送邮件给用户即可，邮件服务不需要参与到会员服务的活动决策中。</p><p>对于此种业务场景，可以使用异步确保型TCC分布式事务解决方案，如下：<br><img src="/images/pasted-50.png" alt="upload successful"><br>由可靠消息服务来解耦会员和邮件服务，会员服务与消息服务组成 TCC 事务模型，保证事务原子性。然后通过消息服务的可靠特性，确保消息一定能够被邮件服务消费，从而使得会员与邮件服务在同一个分布式事务中。同时，邮件服务也不会影响会员服务的执行过程，只在会员服务执行成功后被动接收发送邮件的请求。</p><h6 id="补偿型-TCC-解决方案"><a href="#补偿型-TCC-解决方案" class="headerlink" title="补偿型 TCC 解决方案"></a>补偿型 TCC 解决方案</h6><p>补偿型 TCC 解决方案与通用型 TCC 解决方案的结构相似，其从业务服务也需要参与到主业务服务的活动决策当中。但不一样的是，前者的从业务服务只需要提供 Do 和 Compensate 两个接口，而后者需要提供三个接口。<br><img src="/images/pasted-51.png" alt="upload successful"><br>Do 接口直接执行真正的完整业务逻辑，完成业务处理，业务执行结果外部可见；Compensate 操作用于业务补偿，抵消或部分抵消正向业务操作的业务结果，Compensate操作需满足幂等性。<br>与通用型解决方案相比，补偿型解决方案的从业务服务不需要改造原有业务逻辑，只需要额外增加一个补偿回滚逻辑即可，业务改造量较小。但要注意的是，业务在一阶段就执行完整个业务逻辑，无法做到有效的事务隔离，当需要回滚时，可能存在补偿失败的情况，还需要额外的异常处理机制，比如人工介入。<br><strong>适用场景</strong><br>由于存在回滚补偿失败的情况，补偿型 TCC 分布式事务解决方案只适用于一些并发冲突较少或者需要与外部交互的业务，这些外部业务不属于被动型业务，其执行结果会影响主业务服务的决策，比如机票代理商的机票预订服务：<br><img src="/images/pasted-52.png" alt="upload successful"><br>该机票服务提供多程机票预订服务，可以同时预订多趟行程航班机票，比如从北京到圣彼得堡，需要第一程从北京到莫斯科，以及第二程从莫斯科到圣彼得堡。<br>当用户预订机票时，肯定希望能同时预订这两趟航班的机票，只预订一趟航班对用户来说没有意义。因此，对于这样的业务服务同样提出了原子性要求，如果其中一趟航班的机票预订失败，另外一趟需要能够取消预订。<br>但是，由于航空公司相对于机票代理商来说属于外部业务，只提供订票接口和取消预订接口，想要推动航空公司改造是极其困难的。因此，对于此类业务服务，可以使用补偿型 TCC 分布式事务解决方案，如下：<br><img src="/images/pasted-53.png" alt="upload successful"><br>网关服务在原有逻辑基础上增加 Compensate 接口，负责调用对应航空公司的取消预订接口。<br>在用户发起机票预订请求时，机票服务先通过网关 Do 接口，调用各航空公司的预订接口，如果所有航班都预订成功，则整个分布式事务直接执行成功；一旦某趟航班机票预订失败，则分布式事务回滚，由 TCC 事务框架调用各网关的 Compensate 补偿接口，其再调用对应航空公司的取消预订接口。通过这种方式，也可以保证多程机票预订服务的原子性。</p><h6 id="总-结"><a href="#总-结" class="headerlink" title="总 结"></a>总 结</h6><p>对于现在的互联网应用来说，资源横向扩展提供了更多的灵活性，是一种比较容易实现的向外扩展方案，但是同时也明显增加了复杂度，引入一些新的挑战，比如资源之间的数据一致性问题。<br>横向数据扩展既可以按数据分片扩展，也可以按功能扩展。XA 与 TCC 模型在这一点上的作用类似，都能在横向扩展资源的同时，保证多资源访问的事务属性，只不过前者作用于数据分片时，后者作用于功能扩展时。<br>XA 模型另外一个意义在于其普适性，抛开性能问题的情况下，几乎可以适用于所有业务模式，这对于一些基础性的技术产品来说是非常有用的，比如分布式数据库、云服务的分布式事务框架等。  </p><p>TCC 模型除了跨服务的分布式事务这一层作用之外，还具有两阶段划分的功能，通过业务资源锁定，允许第二阶段的异步执行，而异步化思想正是解决热点数据并发性能问题的利器之一。<br>当然TCC方案也有不足之处，集中表现在以下两个方面：</p><ul><li>对应用的侵入性强。业务逻辑的每个分支都需要实现try、confirm、cancel三个操作，应用侵入性较强，改造成本高。</li><li>实现难度较大。需要按照网络状态、系统故障等不同的失败原因实现不同的回滚策略。为了满足一致性的要求，confirm和cancel接口必须实现幂等。  </li></ul><h5 id="4-GTS－阿里分布式事务解决方案"><a href="#4-GTS－阿里分布式事务解决方案" class="headerlink" title="4 GTS－阿里分布式事务解决方案"></a>4 GTS－阿里分布式事务解决方案</h5><p>GTS是一款分布式事务中间件，由阿里巴巴中间件部门研发，可以为微服务架构中的分布式事务提供一站式解决方案。</p><p><strong>4.1 GTS的核心优势</strong></p><ul><li><p>性能超强<br>GTS通过大量创新，解决了事务ACID特性与高性能、高可用、低侵入不可兼得的问题。单事务分支的平均响应时间在2ms左右，3台服务器组成的集群可以支撑3万TPS以上的分布式事务请求。</p></li><li><p>应用侵入性极低<br>GTS对业务低侵入，业务代码最少只需要添加一行注解（@TxcTransaction）声明事务即可。业务与事务分离，将微服务从事务中解放出来，微服务关注于业务本身，不再需要考虑反向接口、幂等、回滚策略等复杂问题，极大降低了微服务开发的难度与工作量。</p></li><li><p>完整解决方案<br>GTS支持多种主流的服务框架，包括EDAS，Dubbo，Spring Cloud等。 有些情况下，应用需要调用第三方系统的接口，而第三方系统没有接入GTS。此时需要用到GTS的MT模式。GTS的MT模式可以等价于TCC模式，用户可以根据自身业务需求自定义每个事务阶段的具体行为。MT模式提供了更多的灵活性，可能性，以达到特殊场景下的自定义优化及特殊功能的实现。</p></li><li><p>容错能力强<br>GTS解决了XA事务协调器单点问题，实现真正的高可用，可以保证各种异常情况下的严格数据一致。</p></li></ul><p><strong>4.2 GTS的应用场景</strong></p><p>GTS可应用在涉及服务调用的多个领域，包括但不限于金融支付、电信、电子商务、快递物流、广告营销、社交、即时通信、手游、视频、物联网、车联网等。</p><p><strong>4.3 GTS与微服务的集成</strong></p><p>GTS包括客户端（GTS Client）、资源管理器（GTS RM）和事务协调器（GTS Server）三个部分。GTS Client主要用来界定事务边界，完成事务的发起与结束。GTS RM完成事务分支的创建、提交、回滚等操作。GTS Server主要负责分布式事务的整体推进，事务生命周期的管理。GTS和微服务集成的结构图如下所示，GTS Client需要和业务应用集成部署，RM与微服务集成部署。<br><img src="/images/pasted-30.png" alt="upload successful"></p><p><strong>4.4 GTS的输出形式</strong></p><p>GTS目前有三种输出形式：公有云输出、公网输出、专有云输出。</p><p>公有云输出<br>这种输出形式面向阿里云用户。如果用户的业务系统已经部署到阿里云上，可以申请开通公有云GTS。开通后业务应用即可通过GTS保证服务调用的一致性。这种使用场景下，业务系统和GTS间的网络环境比较理想，达到很好性能。<br><img src="/images/pasted-31.png" alt="upload successful"></p><p>公网输出<br>这种输出形式面向于非阿里云的用户，使用更加方便、灵活，业务系统只要能连接互联网即可享受GTS提供的云服务（与公有云输出的差别在于客户端部署于用户本地，而不在云上）。<br>在正常网络环境下，以包含两个本地事务的全局事务为例，事务完成时间在20ms左右，50个并发就可以轻松实现1000TPS以上分布式事务，对绝大多数业务来说性能是足够的。在公网环境，网络闪断很难完全避免，这种情况下GTS仍能保证服务调用的数据一致性。<br><img src="/images/pasted-32.png" alt="upload successful"></p><p>专有云输出<br>这种形式主要面向于已建设了自己专有云平台的大用户，GTS可以直接部署到用户的专有云上，为专有云提供分布式事务服务。目前已经有10多个特大型企业的专有云使用GTS解决分布式事务难题，性能与稳定性经过了用户的严格检测。</p><p><strong>4.5 GTS的使用方式</strong></p><p>GTS对应用的侵入性非常低，使用也很简单。下面以订单存储应用为例说明。订单业务应用通过调用订单服务和库存服务完成订单业务，服务开发框架为Dubbo。</p><p>订单业务应用<br>在业务函数外围使用@TxcTransaction注解即可开启分布式事务。Dubbo应用通过隐藏参数将GTS的事务xid传播到服务端。<br><img src="/images/pasted-33.png" alt="upload successful"></p><p>服务提供者<br>更新库存方法<br><img src="/images/pasted-34.png" alt="upload successful"></p><p><strong>4.6 GTS的应用情况</strong></p><p>GTS目前已经在淘宝、天猫、阿里影业、淘票票、阿里妈妈、1688等阿里各业务系统广泛使用，经受了16年和17年两年双十一海量请求的考验。某线上业务系统最高流量已达十万TPS（每秒钟10万笔事务）。</p><p>GTS在公有云和专有云输出后，已经有了100多个线上用户，很多用户通过GTS解决SpringCloud、Dubbo、Edas等服务框架的分布式事务问题。业务领域涉及电力、物流、ETC、烟草、金融、零售、电商、共享出行等十几个行业，得到用户的一致认可。<br><img src="/images/pasted-35.png" alt="upload successful"><br>上图是GTS与SpringCloud集成，应用于某共享出行系统。业务共享出行场景下，通过GTS支撑物联网系统、订单系统、支付系统、运维系统、分析系统等系各统应用的数据一致性，保证海量订单和数千万流水的交易。</p><p><strong>4.7 GTS的工程样例</strong></p><p>GTS的公有云样例可参考阿里云网站。在公网环境下提供sample-txc-simple和sample-txc-dubbo两个样例工程。</p><p><strong>样例业务逻辑</strong><br>该样例是GTS的入门sample，案例的业务逻辑是从A账户转账给B账户，其中A和B分别位于两个MySQL数据库中，使用GTS事务保证A和B账户钱的总数始终不变。</p><p><strong>样例搭建方法</strong></p><p>1) 准备数据库环境</p><p>安装MySQL，创建两个数据库db1和db2。在db1和db2中分别创建txc_undo_log表（SQL脚本见4.7.3）。在db1库中创建user_money_a表，在db2库中创建user_money_b表。</p><p>2) 下载样例</p><p>将sample-txc-simple文件下载到本地，样例中已经包含了GTS的SDK。</p><p>3) 修改配置</p><p>打开sample-txc-simple/src/main/resources目录下的txc-client-context.xml，将数据源的url、username、password修改为实际值。</p><p>4) 运行样例</p><p>在sample-txc-simple目录下执行build.sh编译本工程。编译完成后执行run.sh。</p><p><strong>sample-txc-dubbo 样例</strong></p><p><strong>样例业务逻辑</strong></p><p>本案例模拟了用户下订单、减库存的业务逻辑。客户端（Client）通过调用订单服务（OrderService）创建订单，之后通过调用库存服务（StockService）扣库存。其中订单服务读写订单数据库，库存服务读写库存数据库。由 GTS 保证跨服务事务的一致性。</p><p><strong>样例搭建方法</strong><br>1) 准备数据库环境<br>安装MySQL，创建两个数据库db1和db2。在db1和db2中分别创建txc_undo_log表。在db1库中创建orders表，在db2库中创建stock表。</p><p>2) 下载样例<br>将样例文件sample-txc-dubbo下载到本地机器，样例中已经包含了GTS的SDK。</p><p>3) 修改配置<br>打开sample-txc-dubbo/src/main/resources目录，将dubbo-order-service.xml、dubbo-stock-service.xml两个文件中数据源的url、username、password修改为实际值。</p><p>4) 运行样例</p><p>a. 编译程序</p><p>在工程根目录执行 build.sh 命令，编译工程。编译后会在 sample-txc-dubbo/client/bin 目录下生成 order_run.sh、stock_run.sh、client_run.sh 三个运行脚本对应订单服务、库存服务以及客户端。</p><p>b. 运行程序</p><p>在根目录执行run.sh，该脚本会依次启动order_run.sh(订单服务)、stock_run.sh(库存服务)和client_run.sh(客户端程序)。</p><p><strong>其他说明</strong></p><p>样例使用Multicast注册中心的声明方式。如果本机使用无线网络，dubbo服务在绑定地址时有可能获取ipv6地址，可以通过jvm启动参数禁用。 方法是配置jvm启动参数 -Djava.net.preferIPv4Stack=true。</p><p><strong>SQL</strong></p><p>建表 txc_undo_log</p><pre><code>CREATE TABLE txc_undo_log (id bigint(20) NOT NULL AUTO_INCREMENT COMMENT &#39;主键&#39;,gmt_create datetime NOT NULL COMMENT &#39;创建时间&#39;,gmt_modified datetime NOT NULL COMMENT &#39;修改时间&#39;,xid varchar(100) NOT NULL COMMENT &#39;全局事务ID&#39;,branch_id bigint(20) NOT NULL COMMENT &#39;分支事务ID&#39;,rollback_info longblob NOT NULL COMMENT &#39;LOG&#39;,status int(11) NOT NULL COMMENT &#39;状态&#39;,server varchar(32) NOT NULL COMMENT &#39;分支所在DB IP&#39;,PRIMARY KEY (id),KEY unionkey (xid,branch_id)) ENGINE=InnoDB AUTO_INCREMENT=211225994 DEFAULT CHARSET=utf8 COMMENT=&#39;事务日志表&#39;;</code></pre><p>建表 user_money_a</p><pre><code>CREATE TABLE user_money_a (id int(11) NOT NULL AUTO_INCREMENT,money int(11) DEFAULT NULL,PRIMARY KEY (id)) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8;</code></pre><p>建表 user_money_b</p><pre><code>CREATE TABLE user_money_b (id int(11) NOT NULL AUTO_INCREMENT,money int(11) DEFAULT NULL,PRIMARY KEY (id)) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8;</code></pre><p>建表 orders</p><pre><code>CREATE TABLE orders (id bigint(20) NOT NULL AUTO_INCREMENT,user_id varchar(255) NOT NULL,product_id int(11) NOT NULL,number int(11) NOT NULL,gmt_create timestamp NOT NULL,PRIMARY KEY (id)) ENGINE=MyISAM AUTO_INCREMENT=351 DEFAULT CHARSET=utf8</code></pre><p>建表 stock</p><pre><code>CREATE TABLE stock (product_id int(11) NOT NULL,price float NOT NULL,amount int(11) NOT NULL,PRIMARY KEY (product_id)) ENGINE=InnoDB DEFAULT CHARSET=utf8</code></pre><p><strong>参考资料</strong></p><ul><li><a href="https://mp.weixin.qq.com/s/bUtu2nTs0bybnTvk-iLt6Q?" target="_blank" rel="noopener">GTS来了！阿里微服务架构下的分布式事务解决方案</a></li></ul><ul><li><a href="https://mp.weixin.qq.com/s/bUtu2nTs0bybnTvk-iLt6Q?" target="_blank" rel="noopener">分布式事务解决方案与适用场景分析</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java项目性能瓶颈定位（转）</title>
      <link href="/2018/11/12/java-xiang-mu-xing-neng-ping-jing-ding-wei-zhuan/"/>
      <url>/2018/11/12/java-xiang-mu-xing-neng-ping-jing-ding-wei-zhuan/</url>
      
        <content type="html"><![CDATA[<h4 id="文章目标"><a href="#文章目标" class="headerlink" title="文章目标"></a>文章目标</h4><p>当Java项目出现性能瓶颈的时候，通常先是对资源消耗做分析，包括CPU，文件IO，网络IO，内存；之后再结合相应工具查找消耗主体的程序代码。本文主要介绍系统资源消耗的分析过程，以及常用的Java线程分析方法。 </p><h5 id="CPU分析"><a href="#CPU分析" class="headerlink" title="CPU分析"></a>CPU分析</h5><p>在Linux中，CPU主要用于处理中断、内核及用户任务，优先级为：中断&gt;内核&gt;用户。在分析CPU消耗状况的时候，需要了解以下三个概念。</p><p><strong>上下文切换</strong><br>每个CPU(或多核CPU的每个核心)在同一时间只能执行一个线程&lt;不包括超线程CPU&gt;，Linux采用抢占式调度。当线程执行到达一个时间片后，如果线程有IO阻塞或高优先级线程要执行的时候，Linux将执行线程切换，切换前先保存当前线程执行状态(现场)，并恢复待执行线程状态，这个过程就叫做上下文切换。在Java应用中，文件IO、网络IO、锁等待、线程Sleep操作都会使该线程进行阻塞或睡眠状态，从而触发上下文切换。频繁的上下文切换会造成内核占用较高的CPU，使得响应速度下降。</p><p><strong>运行队列</strong><br>每个CPU核心都维护了一个可运行队列，例如一个4核CPU，启动8个线程，且8个线程都处于可运行状态，平均分配情况下，每个核心的可运行队列里就有2个线程。通常而言，系统的load是由CPU运行队列决定的，假设以上状态维持了1分钟，则1分钟内系统load就是2。运行队列值越大，代表线程要消耗越长的时间才能执行完成。通常建议每个核心运行队列为1-3个。</p><p><strong>利用率</strong><br>CPU利用率指在用户进程，内核，中断处理，IO等待以及空闲五个部分百分比，这五个值是用来分析CPU消耗情况的关键指标。Linux System and NetWork Performent Monitoring建议用户进程/内核消耗比例为 65%-70% / 30%-35% 左右。</p><p>常用top, pidstat, sar, vmstat 1 分析占用情况<br>us：用户进程处理占用百分比<br>sy：内核线程处理占用百分比<br>ni：被nice命令改变优先级的任务所占百分比<br>id：cpu空闲时间占用百分比<br>wa：在执行过程中等待IO所占百分比<br>hi：硬件中断占用百分比<br>si：软件中断占用百分比<br>st：虚拟机偷取时间百分比</p><p>对Java应用而言，线程消耗主要体现在us, sy上：</p><p><strong>us: 用户进程处理占用百分比</strong><br>us占用分析，需要依靠相关命令找出主体消耗线程ID(tid)，然后转化成十六进制(printf “%x\n” tid)，再用 kill -3 java_pid或 jstack -l java_pid 命令dump出线程信息，通过之前的十六进制值在dump信息中找到nid相等的线程，即为消耗CPU的线程。采样的时候要多做几次，保证找到的是真实的消耗线程。<br>在Java应用中如果us占用过高，代表运行的应用程序消耗了大部分CPU，常见为线程一直处理可运行状态(Runnable)，并且无阻塞地执行循环，正则或复杂计算；也可能是每次请求都分配大量内存，导致频繁GC甚至频繁FullGC造成的，这时就需要依靠jvm工具查看了(jps, jmap, jstat等) 。</p><p><strong>sy: 内核线程处理占用百分比</strong><br>sy值过高表示Linux花费大量时间在线程切换上，Java造成原因通常是启动大量线程，且多数线程处理不断阻塞(如IO等待，锁等待)和执行的状态变化中，造成大量上下文切换。这时可通过 kill -3 java_pid或jstack -l java_pid 命令dump出线程信息，找出不断切换线程执行状态的原因(也可以通过TDA分析)。</p><p>如下使用 vmstat 1 查看上下文切换(cs)及sy占用<br><img src="/images/pasted-17.png" alt="upload successful"><br>如果cs值很高的话，再使用 jstack -l java_pid 查看线程堆栈信息，通常可以发现大量线程处于TIMED_WAITING (on object monitor)与Runnable状态转化中，通过on object monitor可以找到锁竞争激烈的代码，从而找出上下文切换的原因。</p><h5 id="文件IO分析"><a href="#文件IO分析" class="headerlink" title="文件IO分析"></a>文件IO分析</h5><p>换出去。因此在查看内存状态时经常发现可用(free)的物理内存不足，但cached用了很多，这是Linux提升文件IO速度的一种方法。这种情况下，如果物理内存足够用，真正的文件IO只有写文件和第一次读的时候才会产生。</p><p>在Linux中文件IO主要通过 pidstat, iostat分析：</p><p>pidstat -d -p java_pid 1 3<br><img src="/images/pasted-18.png" alt="upload successful"><br>KB_rd/s 表示每秒读取的KB数, KB_wr/s表示每秒写入的KB数, 还可以加入-t参数显示具体的线程信息。</p><p>iostat<br><img src="/images/pasted-19.png" alt="upload successful"><br>iostat只能看到整个系统的文件IO，不能查看具体进程消耗情况。Device表示设备卷标名或分区名，tps是每秒的IO请求，是IO消耗关键指标；Blk_read/s表示每秒读的块数量，Blk_wrtn/s表示每秒写的块数量；Blk_read, Blk_wrtn表示总共读写的块数量；当%iowait占用很高的时候，就要关注IO消耗状况了</p><p>这时可以使用 iostat -x 观察：<br><img src="/images/pasted-20.png" alt="upload successful"><br>r/s, w/s 表示每秒读写的请求数, await表示平均每次IO操作的等待时间，avgqu-sz表示等待请求的队列的平均长度，svctm表示平均每次设备执行IO操作的时间，util表示一秒之中有百分之几用于IO操作。</p><p>在Java应用中造成文件IO消耗严重的原因，通常是多个线程进行大量写入操作（如频繁写入日志文件）。这时可以通过pidstat或iostat结合jstack线程信息,找到消耗主体程序。</p><h5 id="网络IO分析"><a href="#网络IO分析" class="headerlink" title="网络IO分析"></a>网络IO分析</h5><p>在分布式Java应用中，网络IO的消耗是非常值得关注的，尤其注意网卡中断是不是均匀地分配到各CPU上(cat /proc/interrupts)。Linux使用sar分析网络IO消耗情况：</p><p>sar -n ALL 1 2<br><img src="/images/pasted-21.png" alt="upload successful"><br>主要观注接包(rxpck/s)，发包(txpck/s)，接包失败(rxerr/s)，发包失败(txerr/s)，丢包(rxdrop/s)，Socket信息(tcpsck , udpsck)。</p><p>由于无法观察具体进程的网络IO消耗，在网络IO消耗高时，只能线程dump，通常这些线程都在进行网络读写操作。在Java网络通信中，通常将对象序列化为字节流发送，反序列化生成对象。</p><h5 id="内存分析"><a href="#内存分析" class="headerlink" title="内存分析"></a>内存分析</h5><p>从Java应用角度上看，内存可分为两部分，即JVM内存与非JVM内存。在JVM中内存消耗主要体现在堆内存上，内存消耗过高会导致频繁GC甚至FullGC，CPU占用高，可以通过jmap, jstat, mat, visualvm等工具跟踪内存消耗情况；生产环境下，通常将 -Xms 和 -Xmx调整为相同的值，避免运行时不断申请内存。非JVM内存通常只有在创建线程或使用DirectByteBuffer时才会产生，最值得关注的是swap的消耗与物理内存的消耗。</p><p>vmstat<br><img src="/images/pasted-22.png" alt="upload successful"><br>swpd表示虚拟内存已使用的部分(kb)，free空闲物理内存，buff表示用于缓冲的内存，cache表示用于作为缓存的内存。swap下的si表示每秒从disk读到内存的数据量，so每秒从内存写入disk的数据量。swpd过高表示物理内存不够用，系统需要频繁从虚拟内存与disk交换数据，严重影响系统的性能。</p><p>sar -r 2 5<br><img src="/images/pasted-23.png" alt="upload successful"><br>通过sar工具可以看到内存占用，空闲，buff, cache的情况。当物理内存空闲时，Linux会使用一部分内存用于buffer以及cache，以提高系统运行效率。因此可认为系统可用物理内存为 kbmemfree + kbbuffers + kbcached。</p><p>此外还可以使用top, pidstat -r -p [pid][interval][times]</p><p>pidstat -r -p 2448 1 5<br><img src="/images/pasted-24.png" alt="upload successful"></p><h5 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h5><p>中断：<a href="http://blog.csdn.net/pxz_002/article/details/7327668" target="_blank" rel="noopener">http://blog.csdn.net/pxz_002/article/details/7327668</a></p><p>CPU占用分析：<a href="http://www.cnblogs.com/yjf512/p/3383915.html" target="_blank" rel="noopener">http://www.cnblogs.com/yjf512/p/3383915.html</a></p><p>JVM内存分析：<a href="http://my.oschina.net/feichexia/blog/196575" target="_blank" rel="noopener">http://my.oschina.net/feichexia/blog/196575</a></p>]]></content>
      
      
      <categories>
          
          <category> 性能优化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 性能优化 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JVM性能调优监控工具（转）</title>
      <link href="/2018/11/12/jvm-xing-neng-diao-you-jian-kong-gong-ju/"/>
      <url>/2018/11/12/jvm-xing-neng-diao-you-jian-kong-gong-ju/</url>
      
        <content type="html"><![CDATA[<p>现实企业级Java开发中，有时候我们会碰到下面这些问题：</p><ul><li><p>OutOfMemoryError，内存不足</p></li><li><p>内存泄露</p></li><li><p>线程死锁</p></li><li><p>Java进程消耗CPU过高</p></li><li><p>锁争用（Lock Contention）</p></li><li><p>……</p></li></ul><p>这些问题在日常开发中可能被很多人忽视（比如有的人遇到上面的问题只是重启服务器或者调大内存，而不会深究问题根源），但能够理解并解决这些问题是Java程序员进阶的必备要求。本文将对一些常用的JVM性能调优监控工具进行介绍，希望能起抛砖引玉之用。本文参考了网上很多资料，难以一一列举，在此对这些资料的作者表示感谢！关于JVM性能调优相关的资料，请参考文末。</p><p><strong>A、 jps(Java Virtual Machine Process Status Tool) </strong></p><p> jps主要用来输出JVM中运行的进程状态信息。语法格式如下：</p><pre><code> jps [options] [hostid]</code></pre><p>  如果不指定hostid就默认为当前主机或服务器。</p><p>  命令行参数选项说明如下：</p><pre><code>-q 不输出类名、Jar名和传入main方法的参数-m 输出传入main方法的参数-l 输出main类或Jar的全限名-v 输出传入JVM的参数</code></pre><p>  比如下面：</p><pre><code>root@ubuntu:/# jps -m -l2458 org.artifactory.standalone.main.Main /usr/local/artifactory-2.2.5/etc/jetty.xml29920 com.sun.tools.hat.Main -port 9998 /tmp/dump.dat3149 org.apache.catalina.startup.Bootstrap start30972 sun.tools.jps.Jps -m -l8247 org.apache.catalina.startup.Bootstrap start25687 com.sun.tools.hat.Main -port 9999 dump.dat21711 mrf-center.jar</code></pre><p><strong>B、 jstack</strong></p><p>jstack主要用来查看某个Java进程内的线程堆栈信息。语法格式如下：</p><pre><code>jstack [option] pidjstack [option] executable corejstack [option] [server-id@]remote-hostname-or-ip</code></pre><p>命令行参数选项说明如下：</p><pre><code>-l long listings，会打印出额外的锁信息，在发生死锁时可以用jstack -l pid来观察锁持有情况-m mixed mode，不仅会输出Java堆栈信息，还会输出C/C++堆栈信息（比如Native方法）</code></pre><p>jstack可以定位到线程堆栈，根据堆栈信息我们可以定位到具体代码，所以它在JVM性能调优中使用得非常多。下面我们来一个实例找出某个Java进程中最耗费CPU的Java线程并定位堆栈信息，用到的命令有ps、top、printf、jstack、grep。</p><p>第一步先找出Java进程ID，我部署在服务器上的Java应用名称为mrf-center：</p><pre><code>root@ubuntu:/# ps -ef | grep mrf-center | grep -v greproot     21711     1  1 14:47 pts/3    00:02:10 java -jar mrf-center.jar</code></pre><p>得到进程ID为21711，第二步找出该进程内最耗费CPU的线程，可以使用ps -Lfp pid或者ps -mp pid -o THREAD, tid, time或者top -Hp pid，我这里用第三个，输出如下：<br><img src="/images/pasted-13.png" alt="upload successful"></p><p>TIME列就是各个Java线程耗费的CPU时间，CPU时间最长的是线程ID为21742的线程，用</p><pre><code>printf &quot;%x\n&quot; 21742</code></pre><p>得到21742的十六进制值为54ee，下面会用到。    </p><p>OK，下一步终于轮到jstack上场了，它用来输出进程21711的堆栈信息，然后根据线程ID的十六进制值grep，如下：</p><pre><code>root@ubuntu:/# jstack 21711 | grep 54ee&quot;PollIntervalRetrySchedulerThread&quot; prio=10 tid=0x00007f950043e000 nid=0x54ee in Object.wait() [0x00007f94c6eda000]</code></pre><p>可以看到CPU消耗在PollIntervalRetrySchedulerThread这个类的Object.wait()，我找了下我的代码，定位到下面的代码：</p><pre><code>// Idle waitgetLog().info(&quot;Thread [&quot; + getName() + &quot;] is idle waiting...&quot;);schedulerThreadState = PollTaskSchedulerThreadState.IdleWaiting;long now = System.currentTimeMillis();long waitTime = now + getIdleWaitTime();long timeUntilContinue = waitTime - now;synchronized(sigLock) {    try {        if(!halted.get()) {            sigLock.wait(timeUntilContinue);        }    }     catch (InterruptedException ignore) {    }}</code></pre><p>它是轮询任务的空闲等待代码，上面的sigLock.wait(timeUntilContinue)就对应了前面的Object.wait()。</p><p><strong>C、 jmap（Memory Map）和jhat（Java Heap Analysis Tool）</strong></p><p>jmap用来查看堆内存使用状况，一般结合jhat使用。</p><p>jmap语法格式如下：</p><pre><code>jmap [option] pidjmap [option] executable corejmap [option] [server-id@]remote-hostname-or-ip</code></pre><p>如果运行在64位JVM上，可能需要指定-J-d64命令选项参数。</p><pre><code>jmap -permstat pid</code></pre><p>打印进程的类加载器和类加载器加载的持久代对象信息，输出：类加载器名称、对象是否存活（不可靠）、对象地址、父类加载器、已加载的类大小等信息，如下图：<br><img src="/images/pasted-14.png" alt="upload successful"></p><p>使用jmap -heap pid查看进程堆内存使用情况，包括使用的GC算法、堆配置参数和各代中堆内存使用情况。比如下面的例子：</p><pre><code>root@ubuntu:/# jmap -heap 21711Attaching to process ID 21711, please wait...Debugger attached successfully.Server compiler detected.JVM version is 20.10-b01using thread-local object allocation.Parallel GC with 4 thread(s)Heap Configuration:   MinHeapFreeRatio = 40   MaxHeapFreeRatio = 70   MaxHeapSize      = 2067791872 (1972.0MB)   NewSize          = 1310720 (1.25MB)   MaxNewSize       = 17592186044415 MB   OldSize          = 5439488 (5.1875MB)   NewRatio         = 2   SurvivorRatio    = 8   PermSize         = 21757952 (20.75MB)   MaxPermSize      = 85983232 (82.0MB)Heap Usage:PS Young GenerationEden Space:   capacity = 6422528 (6.125MB)   used     = 5445552 (5.1932830810546875MB)   free     = 976976 (0.9317169189453125MB)   84.78829520089286% usedFrom Space:   capacity = 131072 (0.125MB)   used     = 98304 (0.09375MB)   free     = 32768 (0.03125MB)   75.0% usedTo Space:   capacity = 131072 (0.125MB)   used     = 0 (0.0MB)   free     = 131072 (0.125MB)   0.0% usedPS Old Generation   capacity = 35258368 (33.625MB)   used     = 4119544 (3.9287033081054688MB)   free     = 31138824 (29.69629669189453MB)   11.683876009235595% usedPS Perm Generation   capacity = 52428800 (50.0MB)   used     = 26075168 (24.867218017578125MB)   free     = 26353632 (25.132781982421875MB)   49.73443603515625% used   ....</code></pre><p>使用jmap -histo[:live] pid查看堆内存中的对象数目、大小统计直方图，如果带上live则只统计活对象，如下：</p><pre><code>root@ubuntu:/# jmap -histo:live 21711 | more num     #instances         #bytes  class name----------------------------------------------   1:         38445        5597736  &lt;constMethodKlass&gt;   2:         38445        5237288  &lt;methodKlass&gt;   3:          3500        3749504  &lt;constantPoolKlass&gt;   4:         60858        3242600  &lt;symbolKlass&gt;   5:          3500        2715264  &lt;instanceKlassKlass&gt;   6:          2796        2131424  &lt;constantPoolCacheKlass&gt;   7:          5543        1317400  [I   8:         13714        1010768  [C   9:          4752        1003344  [B  10:          1225         639656  &lt;methodDataKlass&gt;  11:         14194         454208  java.lang.String  12:          3809         396136  java.lang.Class  13:          4979         311952  [S  14:          5598         287064  [[I  15:          3028         266464  java.lang.reflect.Method  16:           280         163520  &lt;objArrayKlassKlass&gt;  17:          4355         139360  java.util.HashMap$Entry  18:          1869         138568  [Ljava.util.HashMap$Entry;  19:          2443          97720  java.util.LinkedHashMap$Entry  20:          2072          82880  java.lang.ref.SoftReference  21:          1807          71528  [Ljava.lang.Object;  22:          2206          70592  java.lang.ref.WeakReference  23:           934          52304  java.util.LinkedHashMap  24:           871          48776  java.beans.MethodDescriptor  25:          1442          46144  java.util.concurrent.ConcurrentHashMap$HashEntry  26:           804          38592  java.util.HashMap  27:           948          37920  java.util.concurrent.ConcurrentHashMap$Segment  28:          1621          35696  [Ljava.lang.Class;  29:          1313          34880  [Ljava.lang.String;  30:          1396          33504  java.util.LinkedList$Entry  31:           462          33264  java.lang.reflect.Field  32:          1024          32768  java.util.Hashtable$Entry  33:           948          31440  [Ljava.util.concurrent.ConcurrentHashMap$HashEntry;</code></pre><p>class name是对象类型，说明如下：</p><pre><code>B  byteC  charD  doubleF  floatI  intJ  longZ  boolean[  数组，如[I表示int[][L+类名 其他对象</code></pre><p>还有一个很常用的情况是：用jmap把进程内存使用情况dump到文件中，再用jhat分析查看。jmap进行dump命令格式如下：</p><pre><code>jmap -dump:format=b,file=dumpFileName pid</code></pre><p>我一样地对上面进程ID为21711进行Dump：</p><pre><code>root@ubuntu:/# jmap -dump:format=b,file=/tmp/dump.dat 21711     Dumping heap to /tmp/dump.dat ...Heap dump file created</code></pre><p>dump出来的文件可以用MAT、VisualVM等工具查看，这里用jhat查看：</p><pre><code>root@ubuntu:/# jhat -port 9998 /tmp/dump.datReading from /tmp/dump.dat...Dump file created Tue Jan 28 17:46:14 CST 2014Snapshot read, resolving...Resolving 132207 objects...Chasing references, expect 26 dots..........................Eliminating duplicate references..........................Snapshot resolved.Started HTTP server on port 9998Server is ready.</code></pre><p>注意如果Dump文件太大，可能需要加上-J-Xmx512m这种参数指定最大堆内存，即jhat -J-Xmx512m -port 9998 /tmp/dump.dat。然后就可以在浏览器中输入主机地址:9998查看了：<br><img src="/images/pasted-15.png" alt="upload successful"></p><p>上面红线框出来的部分大家可以自己去摸索下，最后一项支持OQL（对象查询语言）。</p><p><strong>D、jstat（JVM统计监测工具）</strong></p><p>语法格式如下：</p><pre><code>jstat [ generalOption | outputOptions vmid [interval[s|ms] [count]] ]</code></pre><p>vmid是Java虚拟机ID，在Linux/Unix系统上一般就是进程ID。interval是采样时间间隔。count是采样数目。比如下面输出的是GC信息，采样时间间隔为250ms，采样数为4：</p><pre><code>root@ubuntu:/# jstat -gc 21711 250 4 S0C    S1C    S0U    S1U      EC       EU        OC         OU       PC     PU    YGC     YGCT    FGC    FGCT     GCT   192.0  192.0   64.0   0.0    6144.0   1854.9   32000.0     4111.6   55296.0 25472.7    702    0.431   3      0.218    0.649192.0  192.0   64.0   0.0    6144.0   1972.2   32000.0     4111.6   55296.0 25472.7    702    0.431   3      0.218    0.649192.0  192.0   64.0   0.0    6144.0   1972.2   32000.0     4111.6   55296.0 25472.7    702    0.431   3      0.218    0.649192.0  192.0   64.0   0.0    6144.0   2109.7   32000.0     4111.6   55296.0 25472.7    702    0.431   3      0.218    0.649</code></pre><p>要明白上面各列的意义，先看JVM堆内存布局：<br><img src="/images/pasted-16.png" alt="upload successful"></p><p>可以看出：</p><pre><code>堆内存 = 年轻代 + 年老代 + 永久代年轻代 = Eden区 + 两个Survivor区（From和To）</code></pre><p>现在来解释各列含义：</p><pre><code>S0C、S1C、S0U、S1U：Survivor 0/1区容量（Capacity）和使用量（Used）EC、EU：Eden区容量和使用量OC、OU：年老代容量和使用量PC、PU：永久代容量和使用量YGC、YGT：年轻代GC次数和GC耗时FGC、FGCT：Full GC次数和Full GC耗时GCT：GC总耗时</code></pre><p><strong>E、hprof（Heap/CPU Profiling Tool）</strong></p><p>hprof能够展现CPU使用率，统计堆内存使用情况。</p><p>语法格式如下：</p><pre><code>java -agentlib:hprof[=options] ToBeProfiledClassjava -Xrunprof[:options] ToBeProfiledClassjavac -J-agentlib:hprof[=options] ToBeProfiledClass</code></pre><p>完整的命令选项如下：</p><pre><code>Option Name and Value  Description                    Default---------------------  -----------                    -------heap=dump|sites|all    heap profiling                 allcpu=samples|times|old  CPU usage                      offmonitor=y|n            monitor contention             nformat=a|b             text(txt) or binary output     afile=&lt;file&gt;            write data to file             java.hprof[.txt]net=&lt;host&gt;:&lt;port&gt;      send data over a socket        offdepth=&lt;size&gt;           stack trace depth              4interval=&lt;ms&gt;          sample interval in ms          10cutoff=&lt;value&gt;         output cutoff point            0.0001lineno=y|n             line number in traces?         ythread=y|n             thread in traces?              ndoe=y|n                dump on exit?                  ymsa=y|n                Solaris micro state accounting nforce=y|n              force output to &lt;file&gt;         yverbose=y|n            print messages about dumps     y</code></pre><p>来几个官方指南上的实例。</p><p>CPU Usage Sampling Profiling(cpu=samples)的例子：</p><pre><code>java -agentlib:hprof=cpu=samples,interval=20,depth=3 Hello</code></pre><p>上面每隔20毫秒采样CPU消耗信息，堆栈深度为3，生成的profile文件名称是java.hprof.txt，在当前目录。 </p><p>CPU Usage Times Profiling(cpu=times)的例子，它相对于CPU Usage Sampling Profile能够获得更加细粒度的CPU消耗信息，能够细到每个方法调用的开始和结束，它的实现使用了字节码注入技术（BCI）：</p><pre><code>javac -J-agentlib:hprof=cpu=times Hello.java</code></pre><p>Heap Allocation Profiling(heap=sites)的例子：</p><pre><code>javac -J-agentlib:hprof=heap=sites Hello.java</code></pre><p>Heap Dump(heap=dump)的例子，它比上面的Heap Allocation Profiling能生成更详细的Heap Dump信息：</p><pre><code>javac -J-agentlib:hprof=heap=dump Hello.java</code></pre><p>虽然在JVM启动参数中加入-Xrunprof:heap=sites参数可以生成CPU/Heap Profile文件，但对JVM性能影响非常大，不建议在线上服务器环境使用。</p>]]></content>
      
      
      <categories>
          
          <category> 性能优化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 性能优化 </tag>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java多线程问题总结</title>
      <link href="/2018/11/08/java-duo-xian-cheng-wen-ti-zong-jie/"/>
      <url>/2018/11/08/java-duo-xian-cheng-wen-ti-zong-jie/</url>
      
        <content type="html"><![CDATA[<p>40个问题汇总</p><p>1、多线程有什么用？</p><p>一个可能在很多人看来很扯淡的一个问题：我会用多线程就好了，还管它有什么用？在我看来，这个回答更扯淡。所谓”知其然知其所以然”，”会用”只是”知其然”，”为什么用”才是”知其所以然”，只有达到”知其然知其所以然”的程度才可以说是把一个知识点运用自如。OK，下面说说我对这个问题的看法：</p><p>（1）发挥多核CPU的优势</p><p>随着工业的进步，现在的笔记本、台式机乃至商用的应用服务器至少也都是双核的，4核、8核甚至16核的也都不少见，如果是单线程的程序，那么在双核CPU上就浪费了50%，在4核CPU上就浪费了75%。单核CPU上所谓的”多线程”那是假的多线程，同一时间处理器只会处理一段逻辑，只不过线程之间切换得比较快，看着像多个线程”同时”运行罢了。多核CPU上的多线程才是真正的多线程，它能让你的多段逻辑同时工作，多线程，可以真正发挥出多核CPU的优势来，达到充分利用CPU的目的。</p><p>（2）防止阻塞</p><p>从程序运行效率的角度来看，单核CPU不但不会发挥出多线程的优势，反而会因为在单核CPU上运行多线程导致线程上下文的切换，而降低程序整体的效率。但是单核CPU我们还是要应用多线程，就是为了防止阻塞。试想，如果单核CPU使用单线程，那么只要这个线程阻塞了，比方说远程读取某个数据吧，对端迟迟未返回又没有设置超时时间，那么你的整个程序在数据返回回来之前就停止运行了。多线程可以防止这个问题，多条线程同时运行，哪怕一条线程的代码执行读取数据阻塞，也不会影响其它任务的执行。</p><p>（3）便于建模</p><p>这是另外一个没有这么明显的优点了。假设有一个大的任务A，单线程编程，那么就要考虑很多，建立整个程序模型比较麻烦。但是如果把这个大的任务A分解成几个小任务，任务B、任务C、任务D，分别建立程序模型，并通过多线程分别运行这几个任务，那就简单很多了。</p><p>2、创建线程的方式</p><p>比较常见的一个问题了，一般就是两种：</p><p>（1）继承Thread类</p><p>（2）实现Runnable接口</p><p>至于哪个好，不用说肯定是后者好，因为实现接口的方式比继承类的方式更灵活，也能减少程序之间的耦合度，面向接口编程也是设计模式6大原则的核心。</p><p>3、start()方法和run()方法的区别</p><p>只有调用了start()方法，才会表现出多线程的特性，不同线程的run()方法里面的代码交替执行。如果只是调用run()方法，那么代码还是同步执行的，必须等待一个线程的run()方法里面的代码全部执行完毕之后，另外一个线程才可以执行其run()方法里面的代码。</p><p>4、Runnable接口和Callable接口的区别</p><p>有点深的问题了，也看出一个Java程序员学习知识的广度。</p><p>Runnable接口中的run()方法的返回值是void，它做的事情只是纯粹地去执行run()方法中的代码而已；Callable接口中的call()方法是有返回值的，是一个泛型，和Future、FutureTask配合可以用来获取异步执行的结果。</p><p>这其实是很有用的一个特性，因为多线程相比单线程更难、更复杂的一个重要原因就是因为多线程充满着未知性，某条线程是否执行了？某条线程执行了多久？某条线程执行的时候我们期望的数据是否已经赋值完毕？无法得知，我们能做的只是等待这条多线程的任务执行完毕而已。而Callable+Future/FutureTask却可以获取多线程运行的结果，可以在等待时间太长没获取到需要的数据的情况下取消该线程的任务，真的是非常有用。</p><p>5、CyclicBarrier和CountDownLatch的区别</p><p>两个看上去有点像的类，都在java.util.concurrent下，都可以用来表示代码运行到某个点上，二者的区别在于：</p><p>（1）CyclicBarrier的某个线程运行到某个点上之后，该线程即停止运行，直到所有的线程都到达了这个点，所有线程才重新运行；CountDownLatch则不是，某线程运行到某个点上之后，只是给某个数值-1而已，该线程继续运行</p><p>（2）CyclicBarrier只能唤起一个任务，CountDownLatch可以唤起多个任务</p><p>（3）CyclicBarrier可重用，CountDownLatch不可重用，计数值为0该CountDownLatch就不可再用了</p><p>6、volatile关键字的作用</p><p>一个非常重要的问题，是每个学习、应用多线程的Java程序员都必须掌握的。理解volatile关键字的作用的前提是要理解Java内存模型，这里就不讲Java内存模型了，可以参见第31点，volatile关键字的作用主要有两个：</p><p>（1）多线程主要围绕可见性和原子性两个特性而展开，使用volatile关键字修饰的变量，保证了其在多线程之间的可见性，即每次读取到volatile变量，一定是最新的数据</p><p>（2）代码底层执行不像我们看到的高级语言—-Java程序这么简单，它的执行是Java代码–&gt;字节码–&gt;根据字节码执行对应的C/C++代码–&gt;C/C++代码被编译成汇编语言–&gt;和硬件电路交互，现实中，为了获取更好的性能JVM可能会对指令进行重排序，多线程下可能会出现一些意想不到的问题。使用volatile则会对禁止语义重排序，当然这也一定程度上降低了代码执行效率</p><p>从实践角度而言，volatile的一个重要作用就是和CAS结合，保证了原子性，详细的可以参见java.util.concurrent.atomic包下的类，比如AtomicInteger。</p><p>7、什么是线程安全</p><p>又是一个理论的问题，各式各样的答案有很多，我给出一个个人认为解释地最好的：如果你的代码在多线程下执行和在单线程下执行永远都能获得一样的结果，那么你的代码就是线程安全的。</p><p>这个问题有值得一提的地方，就是线程安全也是有几个级别的：</p><p>（1）不可变</p><p>像String、Integer、Long这些，都是final类型的类，任何一个线程都改变不了它们的值，要改变除非新创建一个，因此这些不可变对象不需要任何同步手段就可以直接在多线程环境下使用</p><p>（2）绝对线程安全</p><p>不管运行时环境如何，调用者都不需要额外的同步措施。要做到这一点通常需要付出许多额外的代价，Java中标注自己是线程安全的类，实际上绝大多数都不是线程安全的，不过绝对线程安全的类，Java中也有，比方说CopyOnWriteArrayList、CopyOnWriteArraySet</p><p>（3）相对线程安全</p><p>相对线程安全也就是我们通常意义上所说的线程安全，像Vector这种，add、remove方法都是原子操作，不会被打断，但也仅限于此，如果有个线程在遍历某个Vector、有个线程同时在add这个Vector，99%的情况下都会出现ConcurrentModificationException，也就是fail-fast机制。</p><p>（4）线程非安全</p><p>这个就没什么好说的了，ArrayList、LinkedList、HashMap等都是线程非安全的类</p><p>8、Java中如何获取到线程dump文件</p><p>死循环、死锁、阻塞、页面打开慢等问题，打线程dump是最好的解决问题的途径。所谓线程dump也就是线程堆栈，获取到线程堆栈有两步：</p><p>（1）获取到线程的pid，可以通过使用jps命令，在Linux环境下还可以使用ps -ef | grep java</p><p>（2）打印线程堆栈，可以通过使用jstack pid命令，在Linux环境下还可以使用kill -3 pid</p><p>另外提一点，Thread类提供了一个getStackTrace()方法也可以用于获取线程堆栈。这是一个实例方法，因此此方法是和具体线程实例绑定的，每次获取获取到的是具体某个线程当前运行的堆栈，</p><p>9、一个线程如果出现了运行时异常会怎么样</p><p>如果这个异常没有被捕获的话，这个线程就停止执行了。另外重要的一点是：如果这个线程持有某个某个对象的监视器，那么这个对象监视器会被立即释放</p><p>10、如何在两个线程之间共享数据</p><p>通过在线程之间共享对象就可以了，然后通过wait/notify/notifyAll、await/signal/signalAll进行唤起和等待，比方说阻塞队列BlockingQueue就是为线程之间共享数据而设计的</p><p>11、sleep方法和wait方法有什么区别 </p><p>这个问题常问，sleep方法和wait方法都可以用来放弃CPU一定的时间，不同点在于如果线程持有某个对象的监视器，sleep方法不会放弃这个对象的监视器，wait方法会放弃这个对象的监视器</p><p>12、生产者消费者模型的作用是什么</p><p>这个问题很理论，但是很重要：</p><p>（1）通过平衡生产者的生产能力和消费者的消费能力来提升整个系统的运行效率，这是生产者消费者模型最重要的作用</p><p>（2）解耦，这是生产者消费者模型附带的作用，解耦意味着生产者和消费者之间的联系少，联系越少越可以独自发展而不需要收到相互的制约</p><p>13、ThreadLocal有什么用</p><p>简单说ThreadLocal就是一种以空间换时间的做法，在每个Thread里面维护了一个以开地址法实现的ThreadLocal.ThreadLocalMap，把数据进行隔离，数据不共享，自然就没有线程安全方面的问题了</p><p>14、为什么wait()方法和notify()/notifyAll()方法要在同步块中被调用</p><p>这是JDK强制的，wait()方法和notify()/notifyAll()方法在调用前都必须先获得对象的锁</p><p>15、wait()方法和notify()/notifyAll()方法在放弃对象监视器时有什么区别</p><p>wait()方法和notify()/notifyAll()方法在放弃对象监视器的时候的区别在于：wait()方法立即释放对象监视器，notify()/notifyAll()方法则会等待线程剩余代码执行完毕才会放弃对象监视器。</p><p>16、为什么要使用线程池</p><p>避免频繁地创建和销毁线程，达到线程对象的重用。另外，使用线程池还可以根据项目灵活地控制并发的数目。</p><p>17、怎么检测一个线程是否持有对象监视器</p><p>我也是在网上看到一道多线程面试题才知道有方法可以判断某个线程是否持有对象监视器：Thread类提供了一个holdsLock(Object obj)方法，当且仅当对象obj的监视器被某条线程持有的时候才会返回true，注意这是一个static方法，这意味着”某条线程”指的是当前线程。</p><p>18、synchronized和ReentrantLock的区别</p><p>synchronized是和if、else、for、while一样的关键字，ReentrantLock是类，这是二者的本质区别。既然ReentrantLock是类，那么它就提供了比synchronized更多更灵活的特性，可以被继承、可以有方法、可以有各种各样的类变量，ReentrantLock比synchronized的扩展性体现在几点上：</p><p>（1）ReentrantLock可以对获取锁的等待时间进行设置，这样就避免了死锁</p><p>（2）ReentrantLock可以获取各种锁的信息</p><p>（3）ReentrantLock可以灵活地实现多路通知</p><p>另外，二者的锁机制其实也是不一样的。ReentrantLock底层调用的是Unsafe的park方法加锁，synchronized操作的应该是对象头中mark word，这点我不能确定。</p><p>19、ConcurrentHashMap的并发度是什么</p><p>ConcurrentHashMap的并发度就是segment的大小，默认为16，这意味着最多同时可以有16条线程操作ConcurrentHashMap，这也是ConcurrentHashMap对Hashtable的最大优势，任何情况下，Hashtable能同时有两条线程获取Hashtable中的数据吗？</p><p>20、ReadWriteLock是什么</p><p>首先明确一下，不是说ReentrantLock不好，只是ReentrantLock某些时候有局限。如果使用ReentrantLock，可能本身是为了防止线程A在写数据、线程B在读数据造成的数据不一致，但这样，如果线程C在读数据、线程D也在读数据，读数据是不会改变数据的，没有必要加锁，但是还是加锁了，降低了程序的性能。</p><p>因为这个，才诞生了读写锁ReadWriteLock。ReadWriteLock是一个读写锁接口，ReentrantReadWriteLock是ReadWriteLock接口的一个具体实现，实现了读写的分离，读锁是共享的，写锁是独占的，读和读之间不会互斥，读和写、写和读、写和写之间才会互斥，提升了读写的性能。</p><p>21、FutureTask是什么</p><p>这个其实前面有提到过，FutureTask表示一个异步运算的任务。FutureTask里面可以传入一个Callable的具体实现类，可以对这个异步运算的任务的结果进行等待获取、判断是否已经完成、取消任务等操作。当然，由于FutureTask也是Runnable接口的实现类，所以FutureTask也可以放入线程池中。</p><p>22、Linux环境下如何查找哪个线程使用CPU最长</p><p>这是一个比较偏实践的问题，这种问题我觉得挺有意义的。可以这么做：</p><p>（1）获取项目的pid，jps或者ps -ef | grep java，这个前面有讲过</p><p>（2）top -H -p pid，顺序不能改变</p><p>这样就可以打印出当前的项目，每条线程占用CPU时间的百分比。注意这里打出的是LWP，也就是操作系统原生线程的线程号，我笔记本山没有部署Linux环境下的Java工程，因此没有办法截图演示，网友朋友们如果公司是使用Linux环境部署项目的话，可以尝试一下。</p><p>使用”top -H -p pid”+”jps pid”可以很容易地找到某条占用CPU高的线程的线程堆栈，从而定位占用CPU高的原因，一般是因为不当的代码操作导致了死循环。</p><p>最后提一点，”top -H -p pid”打出来的LWP是十进制的，”jps pid”打出来的本地线程号是十六进制的，转换一下，就能定位到占用CPU高的线程的当前线程堆栈了。</p><p>23、Java编程写一个会导致死锁的程序</p><p>第一次看到这个题目，觉得这是一个非常好的问题。很多人都知道死锁是怎么一回事儿：线程A和线程B相互等待对方持有的锁导致程序无限死循环下去。当然也仅限于此了，问一下怎么写一个死锁的程序就不知道了，这种情况说白了就是不懂什么是死锁，懂一个理论就完事儿了，实践中碰到死锁的问题基本上是看不出来的。</p><p>真正理解什么是死锁，这个问题其实不难，几个步骤：</p><p>（1）两个线程里面分别持有两个Object对象：lock1和lock2。这两个lock作为同步代码块的锁；</p><p>（2）线程1的run()方法中同步代码块先获取lock1的对象锁，Thread.sleep(xxx)，时间不需要太多，50毫秒差不多了，然后接着获取lock2的对象锁。这么做主要是为了防止线程1启动一下子就连续获得了lock1和lock2两个对象的对象锁</p><p>（3）线程2的run)(方法中同步代码块先获取lock2的对象锁，接着获取lock1的对象锁，当然这时lock1的对象锁已经被线程1锁持有，线程2肯定是要等待线程1释放lock1的对象锁的</p><p>这样，线程1”睡觉”睡完，线程2已经获取了lock2的对象锁了，线程1此时尝试获取lock2的对象锁，便被阻塞，此时一个死锁就形成了。代码就不写了，占的篇幅有点多，Java多线程7：死锁这篇文章里面有，就是上面步骤的代码实现。</p><p>24、怎么唤醒一个阻塞的线程</p><p>如果线程是因为调用了wait()、sleep()或者join()方法而导致的阻塞，可以中断线程，并且通过抛出InterruptedException来唤醒它；如果线程遇到了IO阻塞，无能为力，因为IO是操作系统实现的，Java代码并没有办法直接接触到操作系统。</p><p>25、不可变对象对多线程有什么帮助</p><p>前面有提到过的一个问题，不可变对象保证了对象的内存可见性，对不可变对象的读取不需要进行额外的同步手段，提升了代码执行效率。</p><p>26、什么是多线程的上下文切换</p><p>多线程的上下文切换是指CPU控制权由一个已经正在运行的线程切换到另外一个就绪并等待获取CPU执行权的线程的过程。</p><p>27、如果你提交任务时，线程池队列已满，这时会发生什么</p><p>这里区分一下：</p><p>如果使用的是无界队列LinkedBlockingQueue，也就是无界队列的话，没关系，继续添加任务到阻塞队列中等待执行，因为LinkedBlockingQueue可以近乎认为是一个无穷大的队列，可以无限存放任务<br>如果使用的是有界队列比如ArrayBlockingQueue，任务首先会被添加到ArrayBlockingQueue中，ArrayBlockingQueue满了，会根据maximumPoolSize的值增加线程数量，如果增加了线程数量还是处理不过来，ArrayBlockingQueue继续满，那么则会使用拒绝策略RejectedExecutionHandler处理满了的任务，默认是AbortPolicy</p><p>28、Java中用到的线程调度算法是什么</p><p>抢占式。一个线程用完CPU之后，操作系统会根据线程优先级、线程饥饿情况等数据算出一个总的优先级并分配下一个时间片给某个线程执行。</p><p>29、Thread.sleep(0)的作用是什么</p><p>这个问题和上面那个问题是相关的，我就连在一起了。由于Java采用抢占式的线程调度算法，因此可能会出现某条线程常常获取到CPU控制权的情况，为了让某些优先级比较低的线程也能获取到CPU控制权，可以使用Thread.sleep(0)手动触发一次操作系统分配时间片的操作，这也是平衡CPU控制权的一种操作。</p><p>30、什么是自旋</p><p>很多synchronized里面的代码只是一些很简单的代码，执行时间非常快，此时等待的线程都加锁可能是一种不太值得的操作，因为线程阻塞涉及到用户态和内核态切换的问题。既然synchronized里面的代码执行得非常快，不妨让等待锁的线程不要被阻塞，而是在synchronized的边界做忙循环，这就是自旋。如果做了多次忙循环发现还没有获得锁，再阻塞，这样可能是一种更好的策略。</p><p>31、什么是Java内存模型</p><p>Java内存模型定义了一种多线程访问Java内存的规范。Java内存模型要完整讲不是这里几句话能说清楚的，我简单总结一下Java内存模型的几部分内容：</p><p>（1）Java内存模型将内存分为了主内存和工作内存。类的状态，也就是类之间共享的变量，是存储在主内存中的，每次Java线程用到这些主内存中的变量的时候，会读一次主内存中的变量，并让这些内存在自己的工作内存中有一份拷贝，运行自己线程代码的时候，用到这些变量，操作的都是自己工作内存中的那一份。在线程代码执行完毕之后，会将最新的值更新到主内存中去</p><p>（2）定义了几个原子操作，用于操作主内存和工作内存中的变量</p><p>（3）定义了volatile变量的使用规则</p><p>（4）happens-before，即先行发生原则，定义了操作A必然先行发生于操作B的一些规则，比如在同一个线程内控制流前面的代码一定先行发生于控制流后面的代码、一个释放锁unlock的动作一定先行发生于后面对于同一个锁进行锁定lock的动作等等，只要符合这些规则，则不需要额外做同步措施，如果某段代码不符合所有的happens-before规则，则这段代码一定是线程非安全的</p><p>32、什么是CAS</p><p>CAS，全称为Compare and Swap，即比较-替换。假设有三个操作数：内存值V、旧的预期值A、要修改的值B，当且仅当预期值A和内存值V相同时，才会将内存值修改为B并返回true，否则什么都不做并返回false。当然CAS一定要volatile变量配合，这样才能保证每次拿到的变量是主内存中最新的那个值，否则旧的预期值A对某条线程来说，永远是一个不会变的值A，只要某次CAS操作失败，永远都不可能成功。</p><p>33、什么是乐观锁和悲观锁</p><p>（1）乐观锁：就像它的名字一样，对于并发间操作产生的线程安全问题持乐观状态，乐观锁认为竞争不总是会发生，因此它不需要持有锁，将比较-替换这两个动作作为一个原子操作尝试去修改内存中的变量，如果失败则表示发生冲突，那么就应该有相应的重试逻辑。</p><p>（2）悲观锁：还是像它的名字一样，对于并发间操作产生的线程安全问题持悲观状态，悲观锁认为竞争总是会发生，因此每次对某资源进行操作时，都会持有一个独占的锁，就像synchronized，不管三七二十一，直接上了锁就操作资源了。</p><p>34、什么是AQS</p><p>简单说一下AQS，AQS全称为AbstractQueuedSychronizer，翻译过来应该是抽象队列同步器。</p><p>如果说java.util.concurrent的基础是CAS的话，那么AQS就是整个Java并发包的核心了，ReentrantLock、CountDownLatch、Semaphore等等都用到了它。AQS实际上以双向队列的形式连接所有的Entry，比方说ReentrantLock，所有等待的线程都被放在一个Entry中并连成双向队列，前面一个线程使用ReentrantLock好了，则双向队列实际上的第一个Entry开始运行。</p><p>AQS定义了对双向队列所有的操作，而只开放了tryLock和tryRelease方法给开发者使用，开发者可以根据自己的实现重写tryLock和tryRelease方法，以实现自己的并发功能。</p><p>35、单例模式的线程安全性</p><p>老生常谈的问题了，首先要说的是单例模式的线程安全意味着：某个类的实例在多线程环境下只会被创建一次出来。单例模式有很多种的写法，我总结一下：</p><p>（1）饿汉式单例模式的写法：线程安全</p><p>（2）懒汉式单例模式的写法：非线程安全</p><p>（3）双检锁单例模式的写法：线程安全</p><p>36、Semaphore有什么作用</p><p>Semaphore就是一个信号量，它的作用是限制某段代码块的并发数。Semaphore有一个构造函数，可以传入一个int型整数n，表示某段代码最多只有n个线程可以访问，如果超出了n，那么请等待，等到某个线程执行完毕这段代码块，下一个线程再进入。由此可以看出如果Semaphore构造函数中传入的int型整数n=1，相当于变成了一个synchronized了。</p><p>37、Hashtable的size()方法中明明只有一条语句”return count”，为什么还要做同步？</p><p>这是我之前的一个困惑，不知道大家有没有想过这个问题。某个方法中如果有多条语句，并且都在操作同一个类变量，那么在多线程环境下不加锁，势必会引发线程安全问题，这很好理解，但是size()方法明明只有一条语句，为什么还要加锁？</p><p>关于这个问题，在慢慢地工作、学习中，有了理解，主要原因有两点：</p><p>（1）同一时间只能有一条线程执行固定类的同步方法，但是对于类的非同步方法，可以多条线程同时访问。所以，这样就有问题了，可能线程A在执行Hashtable的put方法添加数据，线程B则可以正常调用size()方法读取Hashtable中当前元素的个数，那读取到的值可能不是最新的，可能线程A添加了完了数据，但是没有对size++，线程B就已经读取size了，那么对于线程B来说读取到的size一定是不准确的。而给size()方法加了同步之后，意味着线程B调用size()方法只有在线程A调用put方法完毕之后才可以调用，这样就保证了线程安全性</p><p>（2）CPU执行代码，执行的不是Java代码，这点很关键，一定得记住。Java代码最终是被翻译成机器码执行的，机器码才是真正可以和硬件电路交互的代码。即使你看到Java代码只有一行，甚至你看到Java代码编译之后生成的字节码也只有一行，也不意味着对于底层来说这句语句的操作只有一个。一句”return count”假设被翻译成了三句汇编语句执行，一句汇编语句和其机器码做对应，完全可能执行完第一句，线程就切换了。</p><p>38、线程类的构造方法、静态块是被哪个线程调用的</p><p>这是一个非常刁钻和狡猾的问题。请记住：线程类的构造方法、静态块是被new这个线程类所在的线程所调用的，而run方法里面的代码才是被线程自身所调用的。</p><p>如果说上面的说法让你感到困惑，那么我举个例子，假设Thread2中new了Thread1，main函数中new了Thread2，那么：</p><p>（1）Thread2的构造方法、静态块是main线程调用的，Thread2的run()方法是Thread2自己调用的</p><p>（2）Thread1的构造方法、静态块是Thread2调用的，Thread1的run()方法是Thread1自己调用的</p><p>39、同步方法和同步块，哪个是更好的选择</p><p>同步块，这意味着同步块之外的代码是异步执行的，这比同步整个方法更提升代码的效率。请知道一条原则：同步的范围越小越好。</p><p>借着这一条，我额外提一点，虽说同步的范围越少越好，但是在Java虚拟机中还是存在着一种叫做锁粗化的优化方法，这种方法就是把同步范围变大。这是有用的，比方说StringBuffer，它是一个线程安全的类，自然最常用的append()方法是一个同步方法，我们写代码的时候会反复append字符串，这意味着要进行反复的加锁-&gt;解锁，这对性能不利，因为这意味着Java虚拟机在这条线程上要反复地在内核态和用户态之间进行切换，因此Java虚拟机会将多次append方法调用的代码进行一个锁粗化的操作，将多次的append的操作扩展到append方法的头尾，变成一个大的同步块，这样就减少了加锁–&gt;解锁的次数，有效地提升了代码执行的效率。</p><p>40、高并发、任务执行时间短的业务怎样使用线程池？并发不高、任务执行时间长的业务怎样使用线程池？并发高、业务执行时间长的业务怎样使用线程池？</p><p>这是我在并发编程网上看到的一个问题，把这个问题放在最后一个，希望每个人都能看到并且思考一下，因为这个问题非常好、非常实际、非常专业。关于这个问题，个人看法是：</p><p>（1）高并发、任务执行时间短的业务，线程池线程数可以设置为CPU核数+1，减少线程上下文的切换</p><p>（2）并发不高、任务执行时间长的业务要区分开看：</p><p>　　a）假如是业务时间长集中在IO操作上，也就是IO密集型的任务，因为IO操作并不占用CPU，所以不要让所有的CPU闲下来，可以加大线程池中的线程数目，让CPU处理更多的业务</p><p>　　b）假如是业务时间长集中在计算操作上，也就是计算密集型任务，这个就没办法了，和（1）一样吧，线程池中的线程数设置得少一些，减少线程上下文的切换</p><p>（3）并发高、业务执行时间长，解决这种类型任务的关键不在于线程池而在于整体架构的设计，看看这些业务里面某些数据是否能做缓存是第一步，增加服务器是第二步，至于线程池的设置，设置参考（2）。最后，业务执行时间长的问题，也可能需要分析一下，看看能不能使用中间件对任务进行拆分和解耦。</p>]]></content>
      
      
      <categories>
          
          <category> 多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>分布式系统数据一致性的6种方案(转)</title>
      <link href="/2018/06/09/fen-bu-shi-xi-tong-shu-ju-yi-zhi-xing-de-6-chong-fang-an-zhuan/"/>
      <url>/2018/06/09/fen-bu-shi-xi-tong-shu-ju-yi-zhi-xing-de-6-chong-fang-an-zhuan/</url>
      
        <content type="html"><![CDATA[<h4 id="问题的起源"><a href="#问题的起源" class="headerlink" title="问题的起源"></a>问题的起源</h4><p>在电商等业务中，系统一般由多个独立的服务组成，如何解决分布式调用时候数据的一致性？ </p><p>具体业务场景如下，比如一个业务操作，如果同时调用服务 A、B、C，需要满足要么同时成功；要么同时失败。A、B、C 可能是多个不同部门开发、部署在不同服务器上的远程服务。</p><p>在分布式系统来说，如果不想牺牲一致性，CAP 理论告诉我们只能放弃可用性，这显然不能接受。为了便于讨论问题，先简单介绍下数据一致性的基础理论。</p><h5 id="强一致"><a href="#强一致" class="headerlink" title="强一致"></a>强一致</h5><pre><code>当更新操作完成之后，任何多个后续进程或者线程的访问都会返回最新的更新过的值。这种是对用户最友好的，就是用户上一次写什么，下一次就保证能读到什么。根据 CAP 理论，这种实现需要牺牲可用性。</code></pre><h5 id="弱一致性"><a href="#弱一致性" class="headerlink" title="弱一致性"></a>弱一致性</h5><pre><code>系统并不保证续进程或者线程的访问都会返回最新的更新过的值。系统在数据写入成功之后，不承诺立即可以读到最新写入的值，也不会具体的承诺多久之后可以读到。</code></pre><h5 id="最终一致性"><a href="#最终一致性" class="headerlink" title="最终一致性"></a>最终一致性</h5><pre><code>弱一致性的特定形式。系统保证在没有后续更新的前提下，系统最终返回上一次更新操作的值。在没有故障发生的前提下，不一致窗口的时间主要受通信延迟，系统负载和复制副本的个数影响。DNS 是一个典型的最终一致性系统。</code></pre><p>在工程实践上，为了保障系统的可用性，互联网系统大多将强一致性需求转换成最终一致性的需求，并通过系统执行幂等性的保证，保证数据的最终一致性。但在电商等场景中，对于数据一致性的解决方法和常见的互联网系统（如 MySQL 主从同步）又有一定区别，群友的讨论分成以下 6 种解决方案。</p><h4 id="1-规避分布式事务——业务整合"><a href="#1-规避分布式事务——业务整合" class="headerlink" title="1. 规避分布式事务——业务整合"></a>1. 规避分布式事务——业务整合</h4><p>业务整合方案主要采用将接口整合到本地执行的方法。拿问题场景来说，则可以将服务 A、B、C 整合为一个服务 D 给业务，这个服务 D 再通过转换为本地事务的方式，比如服务 D 包含本地服务和服务 E，而服务 E 是本地服务 A ~ C 的整合。</p><p><strong>优点：</strong>解决（规避）了分布式事务。</p><p><strong>缺点：</strong>显而易见，把本来规划拆分好的业务，又耦合到了一起，业务职责不清晰，不利于维护。</p><p>由于这个方法存在明显缺点，通常不建议使用。</p><h4 id="2-经典方案-eBay-模式"><a href="#2-经典方案-eBay-模式" class="headerlink" title="2. 经典方案 - eBay 模式"></a>2. 经典方案 - eBay 模式</h4><p>此方案的核心是将需要分布式处理的任务通过消息日志的方式来异步执行。消息日志可以存储到本地文本、数据库或消息队列，再通过业务规则自动或人工发起重试。人工重试更多的是应用于支付场景，通过对账系统对事后问题的处理。</p><p><strong>消息日志方案的核心是保证服务接口的幂等性。</strong></p><p>考虑到网络通讯失败、数据丢包等原因，如果接口不能保证幂等性，数据的唯一性将很难保证。</p><p>eBay 方式的主要思路如下。</p><p><strong>Base：一种 Acid 的替代方案</strong></p><p>此方案是 eBay 的架构师 Dan Pritchett 在 2008 年发表给 ACM 的文章，是一篇解释 BASE 原则，或者说最终一致性的经典文章。文中讨论了 BASE 与 ACID 原则在保证数据一致性的基本差异。</p><p>如果 ACID 为分区的数据库提供一致性的选择，那么如何实现可用性呢？答案是</p><p><strong>BASE (basically available, soft state, eventually consistent)</strong></p><p>BASE 的可用性是通过<strong>支持局部故障</strong>而不是系统全局故障来实现的。下面是一个简单的例子：如果将用户分区在 5 个数据库服务器上，BASE 设计鼓励类似的处理方式，一个用户数据库的故障只影响这台特定主机那 20% 的用户。这里不涉及任何魔法，不过它确实可以带来更高的可感知的系统可用性。</p><p>文章中描述了一个最常见的场景，如果产生了一笔交易，需要在交易表增加记录，同时还要修改用户表的金额。这两个表属于不同的远程服务，所以就涉及到分布式事务一致性的问题。<br><img src="/images/pasted-5.png" alt="upload successful"><br>文中提出了一个经典的解决方法，将主要修改操作以及更新用户表的消息<strong>放在一个本地事务</strong>来完成。同时为了避免重复消费用户表消息带来的问题，达到多次重试的幂等性，<strong>增加一个更新记录表 updates_applied</strong> 来记录已经处理过的消息。<br><img src="/images/pasted-6.png" alt="upload successful"><br>系统的执行伪代码如下<br><img src="/images/pasted-7.png" alt="upload successful"><br>基于以上方法，在第一阶段，通过本地的数据库的事务保障，增加了 transaction 表及消息队列 。</p><p>在第二阶段，分别读出消息队列（但不删除），通过判断更新记录表 updates_applied 来检测相关记录是否被执行，未被执行的记录会修改 user 表，然后增加一条操作记录到 updates_applied，事务执行成功之后再删除队列。</p><p>通过以上方法，达到了分布式系统的最终一致性。进一步了解 eBay 的方案可以参考文末链接。</p><h5 id="3-去哪儿网分布式事务方案"><a href="#3-去哪儿网分布式事务方案" class="headerlink" title="3. 去哪儿网分布式事务方案"></a>3. 去哪儿网分布式事务方案</h5><p>随着业务规模不断地扩大，电商网站一般都要面临拆分之路。就是将原来一个单体应用拆分成多个不同职责的子系统。比如以前可能将面向用户、客户和运营的功能都放在一个系统里，现在拆分为订单中心、代理商管理、运营系统、报价中心、库存管理等多个子系统。</p><p><strong>拆分首先要面临的是什么呢？</strong><br>最开始的单体应用所有功能都在一起，存储也在一起。比如运营要取消某个订单，那直接去更新订单表状态，然后更新库存表就 ok 了。因为是单体应用，库在一起，这些都可以在一个事务里，由关系数据库来保证一致性。</p><p>但拆分之后就不同了，不同的子系统都有自己的存储。比如订单中心就只管理自己的订单库，而库存管理也有自己的库。那么运营系统取消订单的时候就是通过接口调用等方式来调用订单中心和库存管理的服务了，而不是直接去操作库。这就涉及一个<strong>『分布式事务』</strong>的问题。</p><p>分布式事务有两种解决方式</p><p><strong>1. 优先使用异步消息。</strong><br>上文已经说过，使用异步消息 Consumer 端需要实现幂等。</p><p>幂等有两种方式，<strong>一种方式是业务逻辑保证幂等</strong>。比如接到支付成功的消息订单状态变成支付完成，如果当前状态是支付完成，则再收到一个支付成功的消息则说明消息重复了，直接作为消息成功处理。</p><p><strong>另外一种方式如果业务逻辑无法保证幂等，则要增加一个去重表或者类似的实现</strong>。对于 producer 端在业务数据库的同实例上放一个消息库，发消息和业务操作在同一个本地事务里。发消息的时候消息并不立即发出，而是向消息库插入一条消息记录，然后在事务提交的时候再异步将消息发出，发送消息如果成功则将消息库里的消息删除，如果遇到消息队列服务异常或网络问题，消息没有成功发出那么消息就留在这里了，会有另外一个服务不断地将这些消息扫出重新发送。</p><p><strong>2. 有的业务不适合异步消息的方式，事务的各个参与方都需要同步的得到结果。</strong><br>这种情况的实现方式其实和上面类似，每个参与方的本地业务库的同实例上面放一个事务记录库。</p><p>比如 A 同步调用 B，C。A 本地事务成功的时候更新本地事务记录状态，B 和 C 同样。如果有一次 A 调用 B 失败了，这个失败可能是 B 真的失败了，也可能是调用超时，实际 B 成功。则由一个中心服务对比三方的事务记录表，做一个最终决定。假设现在三方的事务记录是 A 成功，B 失败，C 成功。那么最终决定有两种方式，根据具体场景：</p><p>重试 B，直到 B 成功，事务记录表里记录了各项调用参数等信息；</p><p>执行 A 和 B 的补偿操作(一种可行的补偿方式是回滚)。</p><p>对 b 场景做一个特殊说明：比如 B 是扣库存服务，在第一次调用的时候因为某种原因失败了，但是重试的时候库存已经变为 0，无法重试成功，这个时候只有回滚 A 和 C 了。</p><p>那么可能有人觉得在业务库的同实例里放消息库或事务记录库，会对业务侵入，业务还要关心这个库，是否一个合理的设计？</p><p>实际上可以依靠运维的手段来简化开发的侵入，我们的方法是让 DBA 在公司所有 MySQL 实例上预初始化这个库，通过框架层（消息的客户端或事务 RPC 框架）透明的在背后操作这个库，业务开发人员只需要关心自己的业务逻辑，不需要直接访问这个库。</p><p>总结起来，其实两种方式的根本原理是类似的，也就是<strong>将分布式事务转换为多个本地事务，然后依靠重试等方式达到最终一致性。</strong></p><p><strong>4. 蘑菇街交易创建过程中的分布式一致性方案</strong>  </p><p><strong>交易创建的一般性流程</strong><br>我们把交易创建流程抽象出一系列可扩展的功能点，每个功能点都可以有多个实现（具体的实现之间有组合/互斥关系）。把各个功能点按照一定流程串起来，就完成了交易创建的过程。<br><img src="/images/pasted-8.png" alt="upload successful"><br><strong>面临的问题</strong><br>每个功能点的实现都可能会依赖外部服务。那么如何保证各个服务之间的数据是一致的呢？比如锁定优惠券服务调用超时了，不能确定到底有没有锁券成功，该如何处理？再比如锁券成功了，但是扣减库存失败了，该如何处理？<br><strong>方案选型</strong><br>服务依赖过多，会带来管理复杂性增加和稳定性风险增大的问题。试想如果我们强依赖 10 个服务，9 个都执行成功了，最后一个执行失败了，那么是不是前面 9 个都要回滚掉？这个成本还是非常高的。<br>所以在拆分大的流程为多个小的本地事务的前提下，对于非实时、非强一致性的关联业务写入，在本地事务执行成功后，我们选择发消息通知、关联事务异步化执行的方案。</p><p><strong>消息通知往往不能保证 100% 成功；且消息通知后，接收方业务是否能执行成功还是未知数。前者问题可以通过重试解决；后者可以选用事务消息来保证。</strong></p><p>但是事务消息框架本身会给业务代码带来侵入性和复杂性，所以我们选择<strong>基于 DB 事件变化通知到 MQ 的方式</strong>做系统间解耦，通过订阅方消费 MQ 消息时的 ACK 机制，保证消息一定消费成功，达到最终一致性。由于消息可能会被重发，消息订阅方业务逻辑处理要做好幂等保证。</p><p>所以目前只剩下需要实时同步做、有强一致性要求的业务场景了。在交易创建过程中，锁券和扣减库存是这样的两个典型场景。</p><p>要保证多个系统间数据一致，乍一看，必须要引入分布式事务框架才能解决。但引入非常重的类似二阶段提交分布式事务框架会带来复杂性的急剧上升；在电商领域，绝对的强一致是过于理想化的，我们可以选择准实时的最终一致性。</p><p>我们在交易创建流程中，<strong>首先创建一个不可见订单</strong>，然后在同步调用锁券和扣减库存时，针对调用异常（失败或者超时），发出废单消息到MQ。如果消息发送失败，本地会做时间阶梯式的异步重试；优惠券系统和库存系统收到消息后，会进行判断是否需要做业务回滚，这样就准实时地保证了多个本地事务的最终一致性。<br><img src="/images/pasted-9.png" alt="upload successful"></p><h5 id="5-支付宝及蚂蚁金融云的分布式服务-DTS-方案"><a href="#5-支付宝及蚂蚁金融云的分布式服务-DTS-方案" class="headerlink" title="5. 支付宝及蚂蚁金融云的分布式服务 DTS 方案"></a>5. 支付宝及蚂蚁金融云的分布式服务 DTS 方案</h5><p>业界常用的还有支付宝的一种 xts 方案，由支付宝在 2PC 的基础上改进而来。主要思路如下，大部分信息引用自官方网站。</p><p><strong>分布式事务服务简介</strong></p><p>分布式事务服务 (Distributed Transaction Service, DTS) 是一个分布式事务框架，用来保障在大规模分布式环境下事务的最终一致性。DTS 从架构上分为 xts-client 和 xts-server 两部分，前者是一个嵌入客户端应用的 JAR 包，主要负责事务数据的写入和处理；后者是一个独立的系统，主要负责异常事务的恢复。</p><p><strong>核心特性</strong></p><p>传统关系型数据库的事务模型必须遵守 ACID 原则。在单数据库模式下，ACID 模型能有效保障数据的完整性，但是在大规模分布式环境下，一个业务往往会跨越多个数据库，如何保证这多个数据库之间的数据一致性，需要其他行之有效的策略。在 JavaEE 规范中使用 2PC (2 Phase Commit, 两阶段提交) 来处理跨 DB 环境下的事务问题，但是 2PC 是反可伸缩模式，也就是说，在事务处理过程中，参与者需要一直持有资源直到整个分布式事务结束。这样，当业务规模达到千万级以上时，2PC 的局限性就越来越明显，系统可伸缩性会变得很差。基于此，我们采用 BASE 的思想实现了一套类似 2PC 的分布式事务方案，这就是 DTS。DTS在充分保障分布式环境下高可用性、高可靠性的同时兼顾数据一致性的要求，其最大的特点是保证数据最终一致 (Eventually consistent)。</p><p>简单的说，DTS 框架有如下特性：</p><p>最终一致：事务处理过程中，会有短暂不一致的情况，但通过恢复系统，可以让事务的数据达到最终一致的目标。</p><p>协议简单：DTS 定义了类似 2PC 的标准两阶段接口，业务系统只需要实现对应的接口就可以使用 DTS 的事务功能。</p><p>与 RPC 服务协议无关：在 SOA 架构下，一个或多个 DB 操作往往被包装成一个一个的 Service，Service 与 Service 之间通过 RPC 协议通信。DTS 框架构建在 SOA 架构上，与底层协议无关。</p><p>与底层事务实现无关： DTS 是一个抽象的基于 Service 层的概念，与底层事务实现无关，也就是说在 DTS 的范围内，无论是关系型数据库 MySQL，Oracle，还是 KV 存储 MemCache，或者列存数据库 HBase，只要将对其的操作包装成 DTS 的参与者，就可以接入到 DTS 事务范围内。</p><p>以下是分布式事务框架的流程图<br><img src="/images/pasted-10.png" alt="upload successful"></p><p><strong>实现</strong></p><p>一个完整的业务活动由一个主业务服务与若干从业务服务组成。<br>主业务服务负责发起并完成整个业务活动。<br>从业务服务提供 TCC 型业务操作。<br>业务活动管理器控制业务活动的一致性，它登记业务活动中的操作，并在活动提交时确认所有的两阶段事务的 confirm 操作，在业务活动取消时调用所有两阶段事务的 cancel 操作。”</p><p><strong>与 2PC 协议比较</strong></p><p>没有单独的 Prepare 阶段，降低协议成本<br>系统故障容忍度高，恢复简单</p><h5 id="6-农信网数据一致性方案"><a href="#6-农信网数据一致性方案" class="headerlink" title="6. 农信网数据一致性方案"></a>6. 农信网数据一致性方案</h5><p><strong>1. 电商业务</strong></p><p>公司的支付部门，通过接入其它第三方支付系统来提供支付服务给业务部门，支付服务是一个基于 Dubbo 的 RPC 服务。</p><p>对于业务部门来说，电商部门的订单支付，需要调用</p><p>支付平台的支付接口来处理订单；<br>同时需要调用积分中心的接口，按照业务规则，给用户增加积分。</p><p>从业务规则上需要同时保证业务数据的实时性和一致性，也就是支付成功必须加积分。</p><p>我们采用的方式是同步调用，首先处理本地事务业务。考虑到积分业务比较单一且业务影响低于支付，由积分平台提供增加与回撤接口。</p><p>具体的流程是先调用积分平台增加用户积分，再调用支付平台进行支付处理，如果处理失败，catch 方法调用积分平台的回撤方法，将本次处理的积分订单回撤。<br><img src="/images/pasted-11.png" alt="upload successful"></p><p><strong>2. 用户信息变更</strong></p><p>公司的用户信息，统一由用户中心维护，而用户信息的变更需要同步给各业务子系统，业务子系统再根据变更内容，处理各自业务。用户中心作为 MQ 的 producer，添加通知给 MQ。APP Server 订阅该消息，同步本地数据信息，再处理相关业务比如 APP 退出下线等。</p><p>我们采用异步消息通知机制，目前主要使用 ActiveMQ，基于 Virtual Topic 的订阅方式，保证单个业务集群订阅的单次消费。<br><img src="/images/pasted-12.png" alt="upload successful"></p><p><strong>总结</strong></p><p>分布式服务对衍生的配套系统要求比较多，特别是我们基于消息、日志的最终一致性方案，需要考虑消息的积压、消费情况、监控、报警等。</p><h5 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h5><p><strong>Base: An Acid Alternative (eBay 方案)</strong><br>In partitioned databases, trading some consistency for availability can lead to dramatic improvements in scalability.<br><a href="http://queue.acm.org/detail.cfm?id=1394128" target="_blank" rel="noopener">http://queue.acm.org/detail.cfm?id=1394128</a> 英文版<br><a href="http://article.yeeyan.org/view/167444/125572" target="_blank" rel="noopener">http://article.yeeyan.org/view/167444/125572</a>  中文版</p><p><strong>分布式事务服务 (DTS) </strong><br><a href="https://www.cloud.alipay.com/docs/middleware/xts/index.html" target="_blank" rel="noopener">https://www.cloud.alipay.com/docs/middleware/xts/index.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>服务降级方案</title>
      <link href="/2018/06/08/fu-wu-jiang-ji-fang-an/"/>
      <url>/2018/06/08/fu-wu-jiang-ji-fang-an/</url>
      
        <content type="html"><![CDATA[<p>开发高并发系统时有三把利器用来保护系统：<strong>缓存、降级</strong>和<strong>限流</strong>。本文将详细聊聊降级。</p><p><strong>为什么需要降级：</strong>当访问量剧增、服务出现问题（如响应时间慢或不响应）或非核心服务影响到核心流程的性能时，仍然需要保证服务还是可用的，即使是有损服务。 </p><p><strong>降级的最终目：</strong>保证核心服务可用，即使是有损的。而且有些服务是无法降级的（如加入购物车、结算）</p><h4 id="降级预案"><a href="#降级预案" class="headerlink" title="降级预案"></a>降级预案</h4><p>在进行降级之前要对系统进行梳理，看看系统是不是可以丢卒保帅；从而梳理出哪些必须誓死保护，哪些可降级；比如可以参考日志级别设置预案：</p><p><strong>一般：</strong>比如有些服务偶尔因为网络抖动或者服务正在上线而超时，可以自动降级；</p><p><strong>警告：</strong>有些服务在一段时间内成功率有波动（如在95~100%之间），可以自动降级或人工降级，并发送告警；</p><p><strong>错误：</strong>比如可用率低于90%，或者数据库连接池被打爆了，或者访问量突然猛增到系统能承受的最大阀值，此时可以根据情况自动降级或者人工降级；</p><p><strong>严重错误：</strong>比如因为特殊原因数据错误了，此时需要紧急人工降级。</p><p>降级按照是否自动化可分为：<strong>自动开关降级</strong>和<strong>人工开关降级</strong>，按照功能可分为：<strong>读服务降级、写服务降级</strong>，按照处于的系统层次可分为：<strong>多级降级</strong>。</p><p>降级的功能点主要从服务端链路考虑，即根据用户访问的服务调用链路来梳理哪里需要降级：</p><p><strong>页面降级：</strong>在大促或者某些特殊情况下，某些页面占用了一些稀缺服务资源，在紧急情况下可以对其整个降级，以达到丢卒保帅；  </p><p><strong>页面片段降级：</strong>比如商品详情页中的商家部分因为数据错误了，此时需要对其进行降级；  </p><p><strong>页面异步请求降级：</strong>比如商品详情页上有推荐信息/配送至等异步加载的请求，如果这些信息响应慢或者后端服务有问题，可以进行降级； </p><p><strong>服务功能降级：</strong>比如渲染商品详情页时需要调用一些不太重要的服务：相 关分类、热销榜等，而这些服务在异常情况下直接不获取，即降级即可；  </p><p><strong>读降级：</strong>比如多级缓存模式，如果后端服务有问题，可以降级为只读缓存，这种方式适用于对读一致性要求不高的场景；</p><p><strong>写降级：</strong>比如秒杀抢购，我们可以只进行Cache的更新，然后异步同步扣减库存到DB，保证最终一致性即可，此时可以将DB降级为Cache。 </p><p><strong>爬虫降级：</strong>在大促活动时，可以将爬虫流量导向静态页或者返回空数据从而降级保护后端稀缺资源。 </p><p><strong>自动开关降级：</strong>自动降级是根据系统负载、资源使用情况、SLA等指标进行降级。  </p><p><strong>超时降级：</strong>当访问的数据库/http服务/远程调用响应慢或者长时间响应慢，且该服务不是核心服务的话可以在超时后自动降级；比如商品详情页上有推荐内容/评价，但是推荐内容/评价暂时不展示对用户购物流 程不会产生很大的影响； 对于这种服务是可以超时降级的。如果是调用别人的远程服务，和对方定义一个服务响应最大时间，如果超时了则自动降级。  </p><p><strong>统计失败次数降级：</strong>有时候依赖一些不稳定的API，比如调用外部机票服务，当失败调用次数达到一定阀值自动降级；然后通过异步线程去探测服务是否恢复了，则取消降级。  </p><p><strong>故障降级：</strong>比如要调用的远程服务挂掉了（网络故障、DNS故障、http服务返回错误的状态码、rpc服务抛出异常），则可以直接降级。降级后的处理方案有：默认值（比如库存服务挂了，返回默认现货）、兜底数据（比如广告挂了，返回提前准备好的一些静态页面）、缓存（之前暂存的一些缓存数据）。  </p><p><strong>限流降级：</strong>当我们去秒杀或者抢购一些限购商品时，此时可能会因为访问量太大而导致系统崩溃，此时开发者会使用限流来进行限制访问量，当达到限流阀值，后续请求会被降级；降级后的处理方案可以是：排队页面（将用户导流到排队页面等一会重试）、无货（直接告知用户没货了）、错误页（如活动太火爆了，稍后重试）。  </p><p><strong>人工开关降级：</strong>在大促期间通过监控发现线上的一些服务存在问题，这个时候需要暂时将这些服务摘掉；还有有时候通过任务系统调用一些服务，但是服务依赖的数据库可能存在：网卡被打满了、挂掉了或者很多慢查询，此时需要暂停下任务系统让服务方进行处理；还有发现突然调用量太大，可能需要改变处理方式（比如同步转换为异步）；此时就可以使用开关来完成降级。</p><p>开关可以存放到配置文件、存放到数据库、存放到Redis/ZooKeeper；如果不是存放在本地，可以定期同步开关数据（比如1秒同步一次）。然后通过判断某个KEY的值来决定是否降级。</p><p>另外对于新开发的服务想上线进行灰度测试；但是不太确定该服务的逻辑是否正确，此时就需要设置开关，当新服务有问题可以通过开关切换回老服务。还有多机房服务，如果某个机房挂掉了，</p><p>此时需要将一个机房的服务切到另一个机房，此时也可以通过开关完成切换。</p><p>还有一些是因为功能问题需要暂时屏蔽掉某些功能，比如商品规格参数数据有问题，数据问题不能用回滚解决，此时需要开关控制降级。</p><p><strong>读服务降级：</strong>对于读服务降级一般采用的策略有：暂时切换读（降级到读缓存、降级到走静态化）、暂时屏蔽读（屏蔽读入口、屏蔽某个读服务）。在《应用多级缓存模式支撑海量读服务》中曾经介绍过读服务，<br>即接入层缓存–&gt;应用层本地缓存–&gt;分布式缓存–&gt;RPC服务/DB，我们会在接入层、应用层设置开关，当分布式缓存、RPC服务/DB有问题自动降级为不调用。当然这种情况适用于对读一致性要求不高的场景。</p><p>页面降级、页面片段降级、页面异步请求降级都是读服务降级，目的是丢卒保帅（比如因为这些服务也要使用核心资源、或者占了带宽影响到核心服务）或者因数据问题暂时屏蔽。</p><p>还有一种是页面静态化场景：</p><p><strong>动态化降级为静态化：</strong>比如平时网站可以走动态化渲染商品详情页，但是到了大促来临之际可以将其切换为静态化来减少对核心资源的占用，而且可以提升性能；其他还有如列表页、首页、频道页都可以这么玩；<br>可以通过一个程序定期的推送静态页到缓存或者生成到磁盘，出问题时直接切过去；</p><p><strong>静态化降级为动态化：</strong>比如当使用静态化来实现商品详情页架构时，平时使用静态化来提供服务，但是因为特殊原因静态化页面有问题了，需要暂时切换回动态化来保证服务正确性。</p><p>以上都保证出问题了有预案，用户还是可以使用网站，不影响用户购物。</p><p><strong>写服务降级：</strong>写服务在大多数场景下是不可降级的，不过可以通过一些迂回战术来解决问题。比如将同步操作转换为异步操作，或者限制写的量/比例。</p><p>比如扣减库存一般这样操作：</p><p><strong>方案1：</strong></p><p>1、扣减DB库存</p><p>2、扣减成功后更新Redis中的库存</p><p><strong>方案2：</strong></p><p>1、扣减Redis库存</p><p>2、同步扣减DB库存，如果扣减失败则回滚Redis库存；</p><p>前两种方案非常依赖DB，假设此时DB性能跟不上则扣减库存就会遇到问题；</p><p><strong>方案3：</strong></p><p>1、扣减Redis库存</p><p>2、正常同步扣减DB库存，性能扛不住时降级为发送一条扣减DB库存的消息，然后异步进行DB库存扣减实现最终一致即可；</p><p>这种方式发送扣减DB库存消息也可能成为瓶颈；这种情况我们可以考虑方案4</p><p><strong>方案4：</strong></p><p>1、扣减Redis库存</p><p>2、正常同步扣减DB库存，性能扛不住时降级为写扣减DB库存消息到本机，然后本机通过异步进行DB库存扣减来实现最终一致性。</p><p>也就是说正常情况可以同步扣减库存，在性能扛不住时降级为异步；另外如果是秒杀场景可以直接降级为异步，从而保护系统。还有如下单操作可以在大促时暂时降级将下单数据写入Redis，然后等峰值过去了再同步回DB，当然也有更好的解决方案，但是更复杂，不是本文的重点。</p><p>还有如用户评价，如果评价量太大，也可以把评价从同步写降级为异步写。当然也可以对评价按钮进行按比例开放（比如一些人的看不到评价操作按钮）。比如评价成功后会发一些奖励，在必要的时候降级同步到异步。</p><p><strong>多级降级：</strong>缓存是离用户最近越高效；而降级是离用户越近越能对系统保护的好。因为业务的复杂性导致越到后端QPS/TPS越低。</p><p><strong>页面JS降级开关：</strong>主要控制页面功能的降级，在页面中通过JS脚本部署功能降级开关，在适当时机开启/关闭开关；</p><p><strong>接入层降级开关：</strong>主要控制请求入口的降级，请求进入后会首先进入接入层，在接入层可以配置功能降级开关，可以根据实际情况进行自动/人工降级；这个可以参考《京东商品详情页服务闭环实践》，尤其在后端应用服务出问题时，通过接入层降级从而给应用服务有足够的时间恢复服务；</p><p><strong>应用层降级开关：</strong>主要控制业务的降级，在应用中配置相应的功能开关，根据实际业务情况进行自动/人工降级。</p><p><strong>某东《服务降级背后的技术架构设计》PPT内容</strong></p><p>牺牲部分用户体验</p><ul><li><p>商详页不显示特色服务icon、促销信息等</p></li><li><p>结算页不显示自提/311/411预约日历</p></li><li><p>订单详情页不显示GIS订单轨迹、催单等</p></li><li><p>评价列表禁止10页之后的翻页</p></li><li><p>实时统计和报表禁用</p></li><li><p>强制必选查询条件中的路由或索引字段</p></li><li><p>领豆豆防刷降级为拼图验证</p></li><li><p>H5变PC页面</p></li><li><p>使用通用内容代替个性化推荐内容</p></li></ul><p>　　降低安全级别</p><ul><li><p>发放京豆、提交订单、发表评论、登录不调用风控接口</p></li><li><p>结算页前端下单不启用验证码</p></li><li><p>集中式session不可用，cookie解密即可</p></li><li><p>ip limit服务，注册、登录不限制次数</p></li><li><p>商品修改内容不做敏感词过滤</p></li></ul><p>　　牺牲部分业务逻辑</p><ul><li><p>拍卖出价时不校验京豆数量</p></li><li><p>发表评价，不再校验是否退货</p></li></ul><p>　　延缓任务处理</p><ul><li><p>WMS任务处理引擎，暂停调拨、节能补贴等任务</p></li><li><p>OFW优先处理高优先级、拆分逻辑较简单的订单</p></li></ul><p>　　损失数据持久性</p><ul><li><p>用户地址更新，写redis，不回写数据库</p></li><li><p>库存预占，写redis，异步回写数据库</p></li><li><p>用户新增普票，写redis，不持久</p></li><li><p>订单二次拆分任务机制，由JMQ降为redis队列</p></li></ul><p>　　降低准确性/实时性</p><ul><li><p>实时价格过期不回源</p></li><li><p>动态页变静态拖底页</p></li><li><p>用户昵称接口降级，显示用户pin</p></li><li><p>库存状态接口降级，显示有货</p></li><li><p>抽奖异常，所有用户均显示未中奖</p></li></ul><p>　　降低性能</p><ul><li><p>数据库代替缓存防重、查询</p></li><li><p>数据库任务队列轮询代替MQ</p></li><li><p>CDN降为源站</p></li><li><p>本地缓存降为RPC</p></li></ul><p>　　降低容灾能力</p><ul><li><p>自动调度变为手工调度</p></li><li><p>VIP降级为real ip</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>服务溶断、降级、限流</title>
      <link href="/2018/06/08/fu-wu-rong-duan-jiang-ji-xian-liu/"/>
      <url>/2018/06/08/fu-wu-rong-duan-jiang-ji-xian-liu/</url>
      
        <content type="html"><![CDATA[<h5 id="服务熔断"><a href="#服务熔断" class="headerlink" title="服务熔断"></a>服务熔断</h5><p>在介绍熔断机制之前，我们需要了解微服务的雪崩效应。在微服务架构中，微服务是完成一个单一的业务功能，这样做的好处是可以做到解耦，每个微服务可以独立演进。但是，一个应用可能会有多个微服务组成，微服务之间的数据交互通过远程过程调用完成。这就带来一个问题，假设微服务A调用微服务B和微服务C，微服务B和微服务C又调用其它的微服务，这就是所谓的“扇出”。如果扇出的链路上某个微服务的调用响应时间过长或者不可用，对微服务A的调用就会占用越来越多的系统资源，进而引起系统崩溃，所谓的“雪崩效应”。<br><img src="/images/pasted-0.png" alt="upload successful"><br>熔断机制是应对雪崩效应的一种微服务链路保护机制。我们在各种场景下都会接触到熔断这两个字。高压电路中，如果某个地方的电压过高，熔断器就会熔断，对电路进行保护。股票交易中，如果股票指数过高，也会采用熔断机制，暂停股票的交易。同样，在微服务架构中，熔断机制也是起着类似的作用。当扇出链路的某个微服务不可用或者响应时间太长时，会进行服务的降级，进而熔断该节点微服务的调用，快速返回错误的响应信息。当检测到该节点微服务调用响应正常后，恢复调用链路。</p><p>在Spring Cloud框架里，熔断机制通过Hystrix实现。Hystrix会监控微服务间调用的状况，当失败的调用到一定阈值，缺省是5秒内20次调用失败，就会启动熔断机制。</p><p>在dubbo中也可利用nio超时+失败次数做熔断。<br>dubbo可以通过扩展Filter的方式引入Hystrix，具体代码如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>netease<span class="token punctuation">.</span>hystrix<span class="token punctuation">.</span>dubbo<span class="token punctuation">.</span>rpc<span class="token punctuation">.</span>filter<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>alibaba<span class="token punctuation">.</span>dubbo<span class="token punctuation">.</span>common<span class="token punctuation">.</span>Constants<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>alibaba<span class="token punctuation">.</span>dubbo<span class="token punctuation">.</span>common<span class="token punctuation">.</span>extension<span class="token punctuation">.</span>Activate<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>alibaba<span class="token punctuation">.</span>dubbo<span class="token punctuation">.</span>rpc<span class="token punctuation">.</span>Filter<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>alibaba<span class="token punctuation">.</span>dubbo<span class="token punctuation">.</span>rpc<span class="token punctuation">.</span>Invocation<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>alibaba<span class="token punctuation">.</span>dubbo<span class="token punctuation">.</span>rpc<span class="token punctuation">.</span>Invoker<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>alibaba<span class="token punctuation">.</span>dubbo<span class="token punctuation">.</span>rpc<span class="token punctuation">.</span>Result<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>alibaba<span class="token punctuation">.</span>dubbo<span class="token punctuation">.</span>rpc<span class="token punctuation">.</span>RpcException<span class="token punctuation">;</span><span class="token annotation punctuation">@Activate</span><span class="token punctuation">(</span>group <span class="token operator">=</span> Constants<span class="token punctuation">.</span>CONSUMER<span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HystrixFilter</span> <span class="token keyword">implements</span> <span class="token class-name">Filter</span> <span class="token punctuation">{</span><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> Result <span class="token function">invoke</span><span class="token punctuation">(</span>Invoker invoker<span class="token punctuation">,</span> Invocation invocation<span class="token punctuation">)</span> <span class="token keyword">throws</span> RpcException <span class="token punctuation">{</span>DubboHystrixCommand command <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DubboHystrixCommand</span><span class="token punctuation">(</span>invoker<span class="token punctuation">,</span> invocation<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> command<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span>DubboHystrixCommand<span class="token keyword">package</span> com<span class="token punctuation">.</span>netease<span class="token punctuation">.</span>hystrix<span class="token punctuation">.</span>dubbo<span class="token punctuation">.</span>rpc<span class="token punctuation">.</span>filter<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>log4j<span class="token punctuation">.</span>Logger<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>alibaba<span class="token punctuation">.</span>dubbo<span class="token punctuation">.</span>common<span class="token punctuation">.</span>URL<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>alibaba<span class="token punctuation">.</span>dubbo<span class="token punctuation">.</span>rpc<span class="token punctuation">.</span>Invocation<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>alibaba<span class="token punctuation">.</span>dubbo<span class="token punctuation">.</span>rpc<span class="token punctuation">.</span>Invoker<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>alibaba<span class="token punctuation">.</span>dubbo<span class="token punctuation">.</span>rpc<span class="token punctuation">.</span>Result<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>netflix<span class="token punctuation">.</span>hystrix<span class="token punctuation">.</span>HystrixCommand<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>netflix<span class="token punctuation">.</span>hystrix<span class="token punctuation">.</span>HystrixCommandGroupKey<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>netflix<span class="token punctuation">.</span>hystrix<span class="token punctuation">.</span>HystrixCommandKey<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>netflix<span class="token punctuation">.</span>hystrix<span class="token punctuation">.</span>HystrixCommandProperties<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>netflix<span class="token punctuation">.</span>hystrix<span class="token punctuation">.</span>HystrixThreadPoolProperties<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DubboHystrixCommand</span> <span class="token keyword">extends</span> <span class="token class-name">HystrixCommand</span> <span class="token punctuation">{</span><span class="token keyword">private</span> <span class="token keyword">static</span> Logger logger <span class="token operator">=</span> Logger<span class="token punctuation">.</span><span class="token function">getLogger</span><span class="token punctuation">(</span>DubboHystrixCommand<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> DEFAULT_THREADPOOL_CORE_SIZE <span class="token operator">=</span> <span class="token number">30</span><span class="token punctuation">;</span><span class="token keyword">private</span> Invoker invoker<span class="token punctuation">;</span><span class="token keyword">private</span> Invocation invocation<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token function">DubboHystrixCommand</span><span class="token punctuation">(</span>Invoker invoker<span class="token punctuation">,</span>Invocation invocation<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">super</span><span class="token punctuation">(</span>Setter<span class="token punctuation">.</span><span class="token function">withGroupKey</span><span class="token punctuation">(</span>HystrixCommandGroupKey<span class="token punctuation">.</span>Factory<span class="token punctuation">.</span><span class="token function">asKey</span><span class="token punctuation">(</span>invoker<span class="token punctuation">.</span><span class="token function">getInterface</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">andCommandKey</span><span class="token punctuation">(</span>HystrixCommandKey<span class="token punctuation">.</span>Factory<span class="token punctuation">.</span><span class="token function">asKey</span><span class="token punctuation">(</span>String<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token string">"%s_%d"</span><span class="token punctuation">,</span> invocation<span class="token punctuation">.</span><span class="token function">getMethodName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>invocation<span class="token punctuation">.</span><span class="token function">getArguments</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> null <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> invocation<span class="token punctuation">.</span><span class="token function">getArguments</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">andCommandPropertiesDefaults</span><span class="token punctuation">(</span>HystrixCommandProperties<span class="token punctuation">.</span><span class="token function">Setter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">withCircuitBreakerRequestVolumeThreshold</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//10秒钟内至少19此请求失败，熔断器才发挥起作用</span><span class="token punctuation">.</span><span class="token function">withCircuitBreakerSleepWindowInMilliseconds</span><span class="token punctuation">(</span><span class="token number">30000</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//熔断器中断请求30秒后会进入半打开状态,放部分流量过去重试</span><span class="token punctuation">.</span><span class="token function">withCircuitBreakerErrorThresholdPercentage</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//错误率达到50开启熔断保护</span><span class="token punctuation">.</span><span class="token function">withExecutionTimeoutEnabled</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//使用dubbo的超时，禁用这里的超时</span><span class="token punctuation">.</span><span class="token function">andThreadPoolPropertiesDefaults</span><span class="token punctuation">(</span>HystrixThreadPoolProperties<span class="token punctuation">.</span><span class="token function">Setter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">withCoreSize</span><span class="token punctuation">(</span><span class="token function">getThreadPoolCoreSize</span><span class="token punctuation">(</span>invoker<span class="token punctuation">.</span><span class="token function">getUrl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//线程池为30</span><span class="token keyword">this</span><span class="token punctuation">.</span>invoker<span class="token operator">=</span>invoker<span class="token punctuation">;</span><span class="token keyword">this</span><span class="token punctuation">.</span>invocation<span class="token operator">=</span>invocation<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/*** 获取线程池大小** @param url* @return*/</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">getThreadPoolCoreSize</span><span class="token punctuation">(</span>URL url<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token punctuation">(</span>url <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">int</span> size <span class="token operator">=</span> url<span class="token punctuation">.</span><span class="token function">getParameter</span><span class="token punctuation">(</span><span class="token string">"ThreadPoolCoreSize"</span><span class="token punctuation">,</span> DEFAULT_THREADPOOL_CORE_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>logger<span class="token punctuation">.</span><span class="token function">isDebugEnabled</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>logger<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"ThreadPoolCoreSize:"</span> <span class="token operator">+</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">return</span> size<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">return</span> DEFAULT_THREADPOOL_CORE_SIZE<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token annotation punctuation">@Override</span><span class="token keyword">protected</span> Result <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span><span class="token keyword">return</span> invoker<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>invocation<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>线程池大小可以通过dubbo参数进行控制，当前其他的参数也可以通过类似的方式进行配置</p><p>代码添加好后在，resource添加加载文本</p><p>|-resources<br>|-META-INF<br>|-dubbo<br>|-com.alibaba.dubbo.rpc.Filter (纯文本文件，内容为：hystrix=com.netease.hystrix.dubbo.rpc.filter.HystrixFilter</p><p>由于Filter定义为自动激活的，所以启动代码所有消费者都被隔离起来啦！</p><p>熔段解决如下几个问题：<br>    当所依赖的对象不稳定时，能够起到快速失败的目的<br>    快速失败后，能够根据一定的算法动态试探所依赖对象是否恢复</p><p>参考：<br><a href="http://www.roncoo.com/article/detail/126834" target="_blank" rel="noopener">http://www.roncoo.com/article/detail/126834</a><br><a href="https://www.cnblogs.com/lvgg/p/7843809.html" target="_blank" rel="noopener">https://www.cnblogs.com/lvgg/p/7843809.html</a>   </p><h5 id="服务降级"><a href="#服务降级" class="headerlink" title="服务降级"></a>服务降级</h5><p>降级是指自己的待遇下降了，从RPC调用环节来讲，就是去访问一个本地的伪装者而不是真实的服务。</p><pre><code>当双11活动时，把无关交易的服务统统降级，如查看蚂蚁深林，查看历史订单，商品历史评论，只显示最后100条等等。</code></pre><h5 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h5><p>相同点：<br>目的很一致，都是从可用性可靠性着想，为防止系统的整体缓慢甚至崩溃，采用的技术手段；<br>最终表现类似，对于两者来说，最终让用户体验到的是某些功能暂时不可达或不可用；<br>粒度一般都是服务级别，当然，业界也有不少更细粒度的做法，比如做到数据持久层（允许查询，不允许增删改）；<br>自治性要求很高，熔断模式一般都是服务基于策略的自动触发，降级虽说可人工干预，但在微服务架构下，完全靠人显然不可能，开关预置、配置中心都是必要手段；</p><p>区别：<br>触发原因不太一样，服务熔断一般是某个服务（下游服务）故障引起，而服务降级一般是从整体负荷考虑；<br>管理目标的层次不太一样，熔断其实是一个框架级的处理，每个微服务都需要（无层级之分），而降级一般需要对业务有层级之分（比如降级一般是从最外围服务开始）<br>实现方式不太一样；服务降级具有代码侵入性(由控制器完成/或自动降级)，熔断一般称为自我熔断。</p><h5 id="服务限流"><a href="#服务限流" class="headerlink" title="服务限流"></a>服务限流</h5><p>在开发高并发系统时有三把利器用来保护系统：缓存、降级和限流。缓存的目的是提升系统访问速度和增大系统能处理的容量，可谓是抗高并发流量的银弹；而降级是当服务出问题或者影响到核心流程的性能则需要暂时屏蔽掉，待高峰或者问题解决后再打开；而有些场景并不能用缓存和降级来解决，比如稀缺资源（秒杀、抢购）、写服务（如评论、下单）、频繁的复杂查询（评论的最后几页），因此需有一种手段来限制这些场景的并发/请求量，即限流。</p><p>限流的目的是通过对并发访问/请求进行限速或者一个时间窗口内的的请求进行限速来保护系统，一旦达到限制速率则可以拒绝服务（定向到错误页或告知资源没有了）、排队或等待（比如秒杀、评论、下单）、降级（返回兜底数据或默认数据，如商品详情页库存默认有货）。</p><p>一般开发高并发系统常见的限流有：限制总并发数（比如数据库连接池、线程池）、限制瞬时并发数（如nginx的limit_conn模块，用来限制瞬时并发连接数）、限制时间窗口内的平均速率（如Guava的RateLimiter、nginx的limit_req模块，限制每秒的平均速率）；其他还有如限制远程接口调用速率、限制MQ的消费速率。另外还可以根据网络连接数、网络流量、CPU或内存负载等来限流。</p><h5 id="限流算法"><a href="#限流算法" class="headerlink" title="限流算法"></a>限流算法</h5><p>常见的限流算法有：令牌桶、漏桶。计数器也可以进行粗暴限流实现。</p><p>漏桶(Leaky Bucket)算法思路很简单,水(请求)先进入到漏桶里,漏桶以一定的速度出水(接口有响应速率),当水流入速度过大会直接溢出(访问频率超过接口响应速率),然后就拒绝请求,可以看出漏桶算法能强行限制数据的传输速率.示意图如下:<br><img src="/images/pasted-1.png" alt="upload successful"></p><p>令牌桶算法(Token Bucket)和 Leaky Bucket 效果一样但方向相反的算法,更加容易理解.随着时间流逝,系统会按恒定1/QPS时间间隔(如果QPS=100,则间隔是10ms)往桶里加入Token(想象和漏洞漏水相反,有个水龙头在不断的加水),如果桶已经满了就不再加了.新请求来临时,会各自拿走一个Token,如果没有Token可拿了就阻塞或者拒绝服务.<br><img src="/images/pasted-2.png" alt="upload successful"><br>令牌桶的另外一个好处是可以方便的改变速度. 一旦需要提高速率,则按需提高放入桶中的令牌的速率. 一般会定时(比如100毫秒)往桶中增加一定数量的令牌, 有些变种算法则实时的计算应该增加的令牌的数量.</p><h5 id="应用级限流"><a href="#应用级限流" class="headerlink" title="应用级限流"></a>应用级限流</h5><p>对于一个应用系统来说一定会有极限并发/请求数，即总有一个TPS/QPS阀值，如果超了阀值则系统就会不响应用户请求或响应的非常慢，因此我们最好进行过载保护，防止大量请求涌入击垮系统。</p><p>如果你使用过Tomcat，其Connector其中一种配置有如下几个参数：<br>acceptCount：如果Tomcat的线程都忙于响应，新来的连接会进入队列排队，如果超出排队大小，则拒绝连接；</p><p>maxConnections：瞬时最大连接数，超出的会排队等待；</p><p>maxThreads：Tomcat能启动用来处理请求的最大线程数，如果请求处理量一直远远大于最大线程数则可能会僵死。</p><p>详细的配置请参考官方文档。另外如MySQL（如max_connections）、Redis（如tcp-backlog）都会有类似的限制连接数的配置。</p><h5 id="池化技术"><a href="#池化技术" class="headerlink" title="池化技术"></a>池化技术</h5><p>如果有的资源是稀缺资源（如数据库连接、线程），而且可能有多个系统都会去使用它，那么需要限制应用；可以使用池化技术来限制总资源数：连接池、线程池。比如分配给每个应用的数据库连接是100，那么本应用最多可以使用100个资源，超出了可以等待或者抛异常。<br>限流某个接口的总并发/请求数</p><p>如果接口可能会有突发访问情况，但又担心访问量太大造成崩溃，如抢购业务；这个时候就需要限制这个接口的总并发/请求数总请求数了；因为粒度比较细，可以为每个接口都设置相应的阀值。可以使用Java中的AtomicLong进行限流：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">try</span> <span class="token punctuation">{</span><span class="token keyword">if</span><span class="token punctuation">(</span>atomic<span class="token punctuation">.</span><span class="token function">incrementAndGet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> 限流数<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//拒绝请求</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//处理请求</span><span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>atomic<span class="token punctuation">.</span><span class="token function">decrementAndGet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>参考：<br><a href="https://blog.csdn.net/g_hongjin/article/details/51649246" target="_blank" rel="noopener">https://blog.csdn.net/g_hongjin/article/details/51649246</a></p><h5 id="分布式限流"><a href="#分布式限流" class="headerlink" title="分布式限流"></a>分布式限流</h5><p>分布式限流最关键的是要将限流服务做成原子化，而解决方案可以使使用redis+lua或者nginx+lua技术进行实现，通过这两种技术可以实现的高并发和高性能。</p><p>首先我们来使用redis+lua实现时间窗内某个接口的请求数限流，实现了该功能后可以改造为限流总并发/请求数和限制总资源数。Lua本身就是一种编程语言，也可以使用它实现复杂的令牌桶或漏桶算法。</p><p>有人会纠结如果应用并发量非常大那么redis或者nginx是不是能抗得住；不过这个问题要从多方面考虑：你的流量是不是真的有这么大，是不是可以通过一致性哈希将分布式限流进行分片，是不是可以当并发量太大降级为应用级限流；对策非常多，可以根据实际情况调节；像在京东使用Redis+Lua来限流抢购流量，一般流量是没有问题的。</p><p>对于分布式限流目前遇到的场景是业务上的限流，而不是流量入口的限流；流量入口限流应该在接入层完成，而接入层笔者一般使用Nginx。</p><h5 id="基于Redis功能的实现限流"><a href="#基于Redis功能的实现限流" class="headerlink" title="基于Redis功能的实现限流"></a>基于Redis功能的实现限流</h5><p>参考：<br><a href="https://www.cnblogs.com/exceptioneye/p/4783904.html" target="_blank" rel="noopener">https://www.cnblogs.com/exceptioneye/p/4783904.html</a><br>简陋的设计思路：假设一个用户（用IP判断）每分钟访问某一个服务接口的次数不能超过10次，那么我们可以在Redis中创建一个键，并此时我们就设置键的过期时间为60秒，<strong>每一个用户对此服务接口的访问就把键值加1，在60秒内当键值增加到10的时候，就禁止访问服务接口。</strong>在某种场景中添加访问时间间隔还是很有必要的。</p><h5 id="基于令牌桶算法的实现"><a href="#基于令牌桶算法的实现" class="headerlink" title="基于令牌桶算法的实现"></a>基于令牌桶算法的实现</h5><p>令牌桶算法最初来源于计算机网络。在网络传输数据时，为了防止网络拥塞，需限制流出网络的流量，使流量以比较均匀的速度向外发送。令牌桶算法就实现了这个功能，可控制发送到网络上数据的数目，并允许突发数据的发送。</p><p>令牌桶算法是网络流量整形（Traffic Shaping）和速率限制（Rate Limiting）中最常使用的一种算法。典型情况下，令牌桶算法用来控制发送到网络上的数据的数目，并允许突发数据的发送。</p><p>大小固定的令牌桶可自行以恒定的速率源源不断地产生令牌。如果令牌不被消耗，或者被消耗的速度小于产生的速度，令牌就会不断地增多，直到把桶填满。后面再产生的令牌就会从桶中溢出。最后桶中可以保存的最大令牌数永远不会超过桶的大小。</p><p>传送到令牌桶的数据包需要消耗令牌。不同大小的数据包，消耗的令牌数量不一样。</p><p>令牌桶这种控制机制基于令牌桶中是否存在令牌来指示什么时候可以发送流量。令牌桶中的每一个令牌都代表一个字节。如果令牌桶中存在令牌，则允许发送流量；而如果令牌桶中不存在令牌，则不允许发送流量。因此，如果突发门限被合理地配置并且令牌桶中有足够的令牌，那么流量就可以以峰值速率发送。</p><p><img src="/images/pasted-3.png" alt="upload successful"></p><p>算法描述：</p><p>假如用户配置的平均发送速率为r，则每隔1/r秒一个令牌被加入到桶中（每秒会有r个令牌放入桶中）；</p><p>假设桶中最多可以存放b个令牌。如果令牌到达时令牌桶已经满了，那么这个令牌会被丢弃；</p><p>当一个n个字节的数据包到达时，就从令牌桶中删除n个令牌（不同大小的数据包，消耗的令牌数量不一样），并且数据包被发送到网络；</p><p>如果令牌桶中少于n个令牌，那么不会删除令牌，并且认为这个数据包在流量限制之外（n个字节，需要n个令牌。该数据包将被缓存或丢弃）；</p><p>算法允许最长b个字节的突发，但从长期运行结果看，数据包的速率被限制成常量r。对于在流量限制外的数据包可以以不同的方式处理：（1）它们可以被丢弃；（2）它们可以排放在队列中以便当令牌桶中累积了足够多的令牌时再传输；（3）它们可以继续发送，但需要做特殊标记，网络过载的时候将这些特殊标记的包丢弃。</p><p>Java实现</p><p>我们可以使用Guava 的 RateLimiter 来实现基于令牌桶的流控，RateLimiter 令牌桶算法是单桶实现。RateLimiter 对简单的令牌桶算法做了一些工程上的优化，具体的实现是 SmoothBursty。需要注意的是，RateLimiter 的另一个实现SmoothWarmingUp，就不是令牌桶了，而是漏桶算法。也许是出于简单起见，RateLimiter 中的时间窗口能且仅能为 1s。</p><p>SmoothBursty 有一个可以放 N 个时间窗口产生的令牌的桶，系统空闲的时候令牌就一直攒着，最好情况下可以扛 N 倍于限流值的高峰而不影响后续请求。RateLimite允许某次请求拿走超出剩余令牌数的令牌，但是下一次请求将为此付出代价，一直等到令牌亏空补上，并且桶中有足够本次请求使用的令牌为止。当某次请求不能得到所需要的令牌时，这时涉及到一个权衡，是让前一次请求干等到令牌够用才走掉呢，还是让它先走掉后面的请求等一等呢？Guava 的设计者选择的是后者，先把眼前的活干了，后面的事后面再说。</p>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Dubbo源码学习</title>
      <link href="/2017/08/02/dubbo-yuan-ma-fen-xi-1-jie-gou/"/>
      <url>/2017/08/02/dubbo-yuan-ma-fen-xi-1-jie-gou/</url>
      
        <content type="html"><![CDATA[<h5 id="阅读源码的作用"><a href="#阅读源码的作用" class="headerlink" title="阅读源码的作用"></a>阅读源码的作用</h5><p>提取设计思路，增强设计能力<br>理解运行机制，便于快速解决问题以及功能扩展</p><h5 id="Dubbo框架设计分层"><a href="#Dubbo框架设计分层" class="headerlink" title="Dubbo框架设计分层"></a>Dubbo框架设计分层</h5><p>配置层（Config）：该层是将业务方的service信息，配置文件的信息收集起来，主要是以ServiceConfig和ReferenceConfig为中心，ServiceConfig是服务提供方的配置，当Spring启动的时候会相应的启动provider服务发布和注册的过程，主要是加入一个ServiceBean继承ServiceConfig在Spring注册。同理ReferenceConfig是consumer方的配置，当消费方启动时，会启动consumer的发现服务订阅服务的过程，当然也是使用一个ReferenceBean继承ReferenceConfig注册在spring上。<br>服务代理层（Proxy）：对服务接口进行透明代理，生成服务的客户端和服务器端，使服务的远程调用就像在本地调用一样。默认使用JavassistProxyFactory，返回一个Invoker，Invoker则是个可执行核心实体，Invoker的invoke方法通过反射执行service方法。<br>服务注册层（Registry）：封装服务地址的注册和发现，以服务URL为中心，基于zk。<br>集群层（Cluster）:提供多个节点并桥接注册中心，主要负责loadBanlance、容错。<br>监控层（Monitor）：RPC调用次数和调用时间监控，以Statistics为中心，扩展接口为MonitorFactory、Monitor和MonitorService。<br>远程调用层（Protocol）：封装RPC调用，provider通过export方法进行暴露服务/consumer通过refer方法调用服务。而Protocol依赖的是Invoker。通过上面说的Proxy获得的Invoker，包装成Exporter。<br>信息交换层（Exchange）：该层封装了请求响应模型，将同步转为异步，信息交换层依赖Exporter，最终将通过网络传输层接收调用请求RequestFuture和ResponseFuture。<br>网络传输层（Transport）：抽象mina和netty为统一接口，以Message为中心，扩展接口为Channel、Transporter、Client、Server和Codec。<br>数据序列化层：将数据序列化反序列化。</p><h5 id="Dubbo源码的结构分层"><a href="#Dubbo源码的结构分层" class="headerlink" title="Dubbo源码的结构分层"></a>Dubbo源码的结构分层</h5><p><img src="/images/pasted-25.png" alt="upload successful"><br><strong>dubbo-common</strong> 公共逻辑模块，包括Util类和通用模型。<br><strong>dubbo-remoting</strong> 远程通讯模块，相当于Dubbo协议的实现，如果RPC用RMI协议则不需要使用此包。<br><strong>dubbo-rpc</strong> 远程调用模块，抽象各种协议，以及动态代理，只包含一对一的调用，不关心集群的管理。<br><strong>dubbo-cluster</strong> 集群模块，将多个服务提供方伪装为一个提供方，包括：负载均衡, 容错，路由等，集群的地址列表可以是静态配置的，也可以是由注册中心下发。<br><strong>dubbo-registry</strong> 注册中心模块，基于注册中心下发地址的集群方式，以及对各种注册中心的抽象。<br><strong>dubbo-monitor</strong>  监控模块，统计服务调用次数，调用时间的，调用链跟踪的服务。<br><strong>dubbo-config</strong>  配置模块，是Dubbo对外的API，用户通过Config使用Dubbo，隐藏Dubbo所有细节。<br><strong>dubbo-container</strong> 容器模块，是一个Standlone的容器，以简单的Main加载Spring启动，因为服务通常不需要Tomcat/JBoss等Web容器的特性，没必要用Web容器去加载服务。 </p><p>整体上按照分层结构进行分包，与分层的不同点在于</p><pre><code>container为服务容器，用于部署运行服务，没有在层中画出。 protocol层和proxy层都放在rpc模块中，这两层是rpc的核心，在不需要集群时(只有一个提供者)，可以只使用这两层完成rpc调用。 transport层和exchange层都放在remoting模块中，为rpc调用的通讯基础。 serialize层放在common模块中，以便更大程度复用。 下面是更详细的Project关系图，依赖关系线有点乱。整个模块是从上到下传递依赖的。 </code></pre><p><img src="/images/pasted-26.png" alt="upload successful"></p><h5 id="Dubbo中采用的设计模式"><a href="#Dubbo中采用的设计模式" class="headerlink" title="Dubbo中采用的设计模式"></a>Dubbo中采用的设计模式</h5><p><strong>1、工厂模式</strong><br>ServiceConfig中有个字段，代码是这样的： </p><p>查看文本打印 </p><p>private static final Protocol protocol=ExtensionLoader.getExtensionLoader(Protocol.class).getAdaptiveExtension();  </p><p>Dubbo里有很多这种代码。这也是一种工厂模式，只是实现类的获取采用了jdkspi的机制。这么实现的优点是可扩展性强，想要扩展实现，只需要在classpath下增加个文件就可以了，代码零侵入。另外，像上面的Adaptive实现，可以做到调用时动态决定调用哪个实现，但是由于这种实现采用了动态代理，会造成代码调试比较麻烦，需要分析出实际调用的实现类。</p><p><strong>2、装饰器模式</strong><br>Dubbo在启动和调用阶段都大量使用了装饰器模式。以Provider提供的调用链为例，具体的调用链代码是在ProtocolFilterWrapper的buildInvokerChain完成的，具体是将注解中含有group=provider的Filter实现，按照order排序，最后的调用顺序是 </p><p>查看文本打印 </p><p>EchoFilter-》ClassLoaderFilter-》GenericFilter-》ContextFilter-》ExceptionFilter-》  </p><p>TimeoutFilter-》MonitorFilter-》TraceFilter。  </p><p>更确切地说，这里是装饰器和责任链模式的混合使用。例如，EchoFilter的作用是判断是否是回声测试请求，是的话直接返回内容，这是一种责任链的体现。而像ClassLoaderFilter则只是在主功能上添加了功能，更改当前线程的ClassLoader，这是典型的装饰器模式。</p><p><strong>3、观察者模式</strong><br>Dubbo的provider启动时，需要与注册中心交互，先注册自己的服务，再订阅自己的服务，订阅时，采用了观察者模式，开启一个listener。注册中心会每5秒定时检查是否有服务更新，如果有更新，向该服务的提供者发送一个notify消息，provider接受到notify消息后，即运行NotifyListener的notify方法，执行监听器方法。 </p><p><strong>4、动态代理模式</strong><br>Dubbo扩展jdkspi的类ExtensionLoader的Adaptive实现是典型的动态代理实现。Dubbo需要灵活地控制实现类，即在调用阶段动态地根据参数决定调用哪个实现类，所以采用先生成代理类的方法，能够做到灵活的调用。生成代理类的代码是ExtensionLoader的createAdaptiveExtensionClassCode方法。代理类的主要逻辑是，获取URL参数中指定参数的值作为获取实现类的key。</p>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 中间件 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hello World</title>
      <link href="/2016/08/01/hello-world/"/>
      <url>/2016/08/01/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
  
  
</search>
